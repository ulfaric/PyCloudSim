{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to PyCloudSim Docs","text":"<p>PyCloudSim is a simulation toolkit written in python to simulate cloud computing with incorporation of Network Service and Service Funtion Chain. It is based a light-weighted discrete event simulation library Akatosh. PyCloudSim is inspired by CloudSim and CloudSim Plus. However, PyCloudSim simulates the computation fundamentally differently.</p> <p>In CloudSim, a computing work is defined as a Cloudlet with a given length. Then, the Cloudlet is scheduled onto VM. The Cloudlet included two functions defined for CPU usage and RAM usage. Hence, the actual resource usages are just random numbers generated from a predefined function.</p> <p>In PyCloudSim, a computing work is defined as vProcess which has a instruction length. Then a set of random bytes are generated as \"instructons\" to determine the RAM usage for this vProcess. Then, PyCloudSim simulates the CPU for scheduling process on multiple core for execution. Hence, vProcess could occupiy one or more vCPUCore at the same time. Each vCPUCore consumes the \"insrtuctions\" according to schedule from vCPU. While vCPUCore is executing \"instructions\", its computational power ( defined by frequency and instructions per cycle ) is considered as been used. After executing, the vCPUCore will regain the used computational power. When a vProcess has its \"instructions\" all been executed, then it is complete. Therefore, the CPU and RAM usage patterns simulated by PyCloudSim are not merely random numbers, they are more realistic to how a real computer should behave.</p> <p>In addtion, PyCloudSim also simulates the network traffic. That is, vPackets will be created along vProcess. Then, vNIC will queue and transmit them! So you can simulate a API call between vContainers! The API call is simulated as vRequest and only when its associated vProcess is complete and all its associated vPackets have reached the destination, the vRequest is complete! This is impossible within CloudSim or CloudSim Plus.</p> <p>If you are using PyCloudSim for your research, please use the following refernece.</p> <pre><code>@INPROCEEDINGS{10329606,\n  author={Ren, Yifei and Agrawal, Himanshu and Ferdosian, Nasim and Nejabati, Reza},\n  booktitle={2023 IEEE Conference on Network Function Virtualization and Software Defined Networks (NFV-SDN)}, \n  title={PyCloudSim: Modernized Cloud Computing Simulation Framework with the Incorporation of SFC}, \n  year={2023},\n  volume={},\n  number={},\n  pages={92-98},\n  doi={10.1109/NFV-SDN59219.2023.10329606}}\n\n</code></pre>"},{"location":"quick_start_guide/","title":"Quick Start Guide","text":""},{"location":"quick_start_guide/#installation","title":"Installation","text":"<p>PyCloudSIm can be easily installed via pip with:</p> <pre><code>pip install -U PyCloudSim\n</code></pre> <p>Its dependencies will be automatically installed!</p>"},{"location":"quick_start_guide/#basic-example","title":"Basic Example","text":"<p>Let's sceipt a basic example of simulation that consists five vHost, one switch and two vMicroservice. To start, we firstly import the modules:</p> <pre><code>from PyCloudSim.entity import vDefaultMicroservice, vHost, vSwitch\n</code></pre> <p>Then, we can create a core switch that connects all the simulated hosts:</p> <pre><code>core_switch = vSwitch(\n    ipc=1,\n    frequency=5000,\n    num_cores=4,\n    cpu_tdps=150,\n    cpu_mode=1,\n    ram=8,\n    rom=16,\n    subnet=IPv4Network(\"192.168.0.0/24\"),\n    label=\"Core\",\n    create_at=0,\n)\ncore_switch.power_on(0)\n</code></pre> <p>Remeber you must call the power on function to actualy power on the simulated switch. Then, we create our hosts and link them with the switch:</p> <pre><code>hosts: List[vHost] = []\nfor i in range(5):\n    host = vHost(\n        ipc=1,\n        frequency=5000,\n        num_cores=4,\n        cpu_tdps=150,\n        cpu_mode=2,\n        ram=2,\n        rom=16,\n        label=str(i),\n        create_at=0,\n    )\n\n    host.power_on(0)\n    simulation.network.add_link(host, core_switch, 1, 0)\n    hosts.append(host)\n</code></pre> <p>Next, we create our microservices:</p> <pre><code>ms_1 = vDefaultMicroservice(\n    cpu=100,\n    cpu_limit=500,\n    ram=500,\n    ram_limit=1000,\n    label=\"test 1\",\n    image_size=100,\n    create_at=0,\n    deamon=True,\n    min_num_instances=2,\n    max_num_instances=4,\n)\n\nms_2 = vDefaultMicroservice(\n    cpu=100,\n    cpu_limit=500,\n    ram=500,\n    ram_limit=1000,\n    label=\"test 2\",\n    image_size=100,\n    create_at=0,\n    deamon=True,\n    min_num_instances=3,\n    max_num_instances=4,\n)\n</code></pre> <p>The \"vDefaultMicroservice\" is similar to a Kubernetes deployment that the number of container instances schedule up and down based on the utilization threshold. The default configuration is scale up whenever CPU or RAM reach 80% and scale down when they reach 20%.</p> <p>Next, we create simulated API calls that engages with the microservice:</p> <pre><code>from Akatosh import instant_event\n\n@instant_event(at=0.11)\ndef test():\n    test = vAPICall(\n        src=ms_1,\n        dst=ms_2,\n        src_process_length=10,\n        dst_process_length=10,\n        ack_process_length=10,\n        num_src_packets=10,\n        num_ret_packets=10,\n        num_ack_packets=10,\n        src_packet_size=100,\n        ret_packet_size=100,\n        ack_packet_size=100,\n        priority=1,\n        create_at=0.11,\n        label=\"test\",\n    )\n\n    post_test = vAPICall(\n        src=ms_2,\n        dst=ms_1,\n        src_process_length=10,\n        dst_process_length=10,\n        ack_process_length=10,\n        num_src_packets=10,\n        num_ret_packets=10,\n        num_ack_packets=10,\n        src_packet_size=100,\n        ret_packet_size=100,\n        ack_packet_size=100,\n        priority=1,\n        create_at=0.11,\n        label=\"Post test\",\n        precursor=test,\n    )\n</code></pre> <p>In this simple example, we simply have one API call after another. You can create a SFC process with a group of API Calls chaining together. This example can be considered as an SFC with two microservices only.</p> <p>Next, we set the container scheduler and use a built in container monitor:</p> <pre><code>from PyCloudSim.monitor.container_monitor import LoggingContainerMonitor\nfrom PyCloudSim.scheduler import DefaultContainerScheduler\n\nDefaultContainerScheduler()\n\nLoggingContainerMonitor(label=\"Container Monitor\", sample_period=0.01)\n</code></pre> <p>Finally, we start the simulation:</p> <pre><code># dsiable debuging messages\nsimulation.debug(False)\n# set simulation to run for 1.5s\nsimulation.simulate(1.5)\n</code></pre> <p>It is very easy to create your own monitor:</p> <pre><code># first, simply extend the base monitor class\nclass MyContainerMonitor(Monitor):\n\n    # secondly, overwrite the on_observation function to what ever you like :)\n    def on_observation(self, *arg, **kwargs):\n        # your codes for what happens when monitor observes.\n        pass\n\n</code></pre>"},{"location":"api/entity/","title":"Enity","text":"<p>The <code>Enity</code> is a class from discrete event simulation library <code>Akatosh</code>. All PyCloudSim simulated entities are built based on it.</p> <p>An entity could be considered as an actor/NPC which lives within the simulated envrionment. The <code>NPC</code> comes to life with <code>create()</code> function and dies with <code>terminate()</code> function. During its life-cycle, the <code>NPC</code> can engage instant event which are the event that happens once at a time point, or continous event that happens multiple times for a period of time. Any future event will be canceled upon the <code>temination</code> of the <code>NPC</code>.</p> <p>Therefore, fundamentally the PyCloudSim is a series of <code>NPC</code> playing the roles of all things involed in cloud computing and networking, with a series of instant event and continous event.</p> <p>For more information, you can visit the <code>Akatosh</code> documentation site: https://ulfaric.github.io/Akatosh/</p>"},{"location":"api/hardware_component/","title":"Hardware Component","text":"<p>The <code>HardwareComponent</code> class is the base class for vCPU, vCPUCore and vNIC. It implements the mandatory abstract functions and property. You can create new physcial component based on this class.</p> <p>             Bases: <code>Entity</code></p> <p>Base class for all hardware components.</p> Source code in <code>PyCloudSim\\entity\\v_hardware_component.py</code> <pre><code>class vHardwareComponent(Entity):\n    \"\"\"Base class for all hardware components.\"\"\"\n\n    def __init__(\n        self,\n        label: str | None = None,\n        create_at: int\n        | float\n        | Callable[..., int]\n        | Callable[..., float]\n        | None = None,\n        terminate_at: int\n        | float\n        | Callable[..., int]\n        | Callable[..., float]\n        | None = None,\n        precursor: Entity | List[Entity] | None = None,\n    ) -&gt; None:\n        \"\"\"Create a new hardware component.\n\n        Args:\n            label (str | None, optional): the short description of this new hardware component. Defaults to None.\n            create_at (int | float | Callable[..., int] | Callable[..., float] | None, optional): when is this hardware component is created. Defaults to None.\n            terminate_at (int | float | Callable[..., int] | Callable[..., float] | None, optional): when this hardware component will be terminated. Defaults to None.\n            precursor (Entity | List[Entity] | None, optional): the other entity that this hardware component must not be created until their termination. Defaults to None.\n        \"\"\"\n        super().__init__(label, create_at, terminate_at, precursor)\n\n    def on_termination(self):\n        \"\"\"Power off upon termination.\"\"\"\n        self.power_off(simulation.now)\n\n    def power_on(self, at: int | float) -&gt; None:\n        \"\"\"Power on the hardware entity\"\"\"\n\n        if self.powered_on:\n            warnings.warn(f\"{self.label} is already powered on.\")\n            return\n\n        if self.failed:\n            warnings.warn(f\"{self.label} is failed.\")\n            return\n\n        if self.terminated:\n            warnings.warn(f\"{self.label} is terminated.\")\n            return\n\n        @self.instant_event(at, label=f\"{self.label} Power On\", priority=-1)\n        def _power_on() -&gt; None:\n            if self.powered_on or self.terminated:\n                return\n            self.on_power_on()\n            self.state.append(Constants.POWER_ON)\n            if Constants.POWER_OFF in self.state:\n                self.state.remove(Constants.POWER_OFF)\n            if Constants.FAIL in self.state:\n                self.state.remove(Constants.FAIL)\n\n    def on_power_on(self) -&gt; None:\n        \"\"\"Called when the hardware entity is powered on\"\"\"\n        pass\n\n    def power_off(self, at: int | float) -&gt; None:\n        \"\"\"Power off the hardware entity\"\"\"\n\n        if self.powered_off:\n            warnings.warn(f\"{self.label} is already powered off.\")\n            return\n        if self.failed:\n            warnings.warn(f\"{self.label} is failed.\")\n            return\n\n        if self.terminated:\n            warnings.warn(f\"{self.label} is terminated.\")\n            return\n\n        @self.instant_event(at, label=f\"{self.label} Power Off\", priority=-1)\n        def _power_off() -&gt; None:\n            if self.powered_off or self.terminated:\n                return\n            self.on_power_off()\n            self.state.append(Constants.POWER_OFF)\n            if Constants.POWER_ON in self.state:\n                self.state.remove(Constants.POWER_ON)\n\n    def on_power_off(self) -&gt; None:\n        \"\"\"Called when the hardware entity is powered off\"\"\"\n        pass\n\n    def fail(self, at: int | float) -&gt; None:\n        \"\"\"Fail the hardware component\"\"\"\n\n        if self.failed:\n            warnings.warn(f\"{self.label} is already failed.\")\n            return\n\n        if self.terminated:\n            warnings.warn(f\"{self.label} is terminated.\")\n            return\n\n        @self.instant_event(at, label=f\"{self.label} Fail\")\n        def _fail() -&gt; None:\n            if self.failed or self.terminated:\n                return\n            self.on_fail()\n            self.power_off(simulation.now)\n            self.state.append(Constants.FAIL)\n\n    def on_fail(self) -&gt; None:\n        \"\"\"Called when the hardware component fails\"\"\"\n        pass\n\n    def __str__(self) -&gt; str:\n        return f\"{self.__class__.__name__}-{self.label}\"\n\n    @property\n    def powered_on(self) -&gt; bool:\n        \"\"\"Return True if the hardware component is powered on\"\"\"\n        return Constants.POWER_ON in self.state\n\n    @property\n    def powered_off(self) -&gt; bool:\n        \"\"\"Return True if the hardware component is powered off\"\"\"\n        return Constants.POWER_OFF in self.state or Constants.POWER_ON not in self.state\n\n    @property\n    def failed(self) -&gt; bool:\n        \"\"\"Return True if the hardware component fails\"\"\"\n        return Constants.FAIL in self.state\n</code></pre>"},{"location":"api/hardware_component/#PyCloudSim.entity.v_hardware_component.vHardwareComponent.failed","title":"<code>failed: bool</code>  <code>property</code>","text":"<p>Return True if the hardware component fails</p>"},{"location":"api/hardware_component/#PyCloudSim.entity.v_hardware_component.vHardwareComponent.powered_off","title":"<code>powered_off: bool</code>  <code>property</code>","text":"<p>Return True if the hardware component is powered off</p>"},{"location":"api/hardware_component/#PyCloudSim.entity.v_hardware_component.vHardwareComponent.powered_on","title":"<code>powered_on: bool</code>  <code>property</code>","text":"<p>Return True if the hardware component is powered on</p>"},{"location":"api/hardware_component/#PyCloudSim.entity.v_hardware_component.vHardwareComponent.__init__","title":"<code>__init__(label=None, create_at=None, terminate_at=None, precursor=None)</code>","text":"<p>Create a new hardware component.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str | None</code> <p>the short description of this new hardware component. Defaults to None.</p> <code>None</code> <code>create_at</code> <code>int | float | Callable[..., int] | Callable[..., float] | None</code> <p>when is this hardware component is created. Defaults to None.</p> <code>None</code> <code>terminate_at</code> <code>int | float | Callable[..., int] | Callable[..., float] | None</code> <p>when this hardware component will be terminated. Defaults to None.</p> <code>None</code> <code>precursor</code> <code>Entity | List[Entity] | None</code> <p>the other entity that this hardware component must not be created until their termination. Defaults to None.</p> <code>None</code> Source code in <code>PyCloudSim\\entity\\v_hardware_component.py</code> <pre><code>def __init__(\n    self,\n    label: str | None = None,\n    create_at: int\n    | float\n    | Callable[..., int]\n    | Callable[..., float]\n    | None = None,\n    terminate_at: int\n    | float\n    | Callable[..., int]\n    | Callable[..., float]\n    | None = None,\n    precursor: Entity | List[Entity] | None = None,\n) -&gt; None:\n    \"\"\"Create a new hardware component.\n\n    Args:\n        label (str | None, optional): the short description of this new hardware component. Defaults to None.\n        create_at (int | float | Callable[..., int] | Callable[..., float] | None, optional): when is this hardware component is created. Defaults to None.\n        terminate_at (int | float | Callable[..., int] | Callable[..., float] | None, optional): when this hardware component will be terminated. Defaults to None.\n        precursor (Entity | List[Entity] | None, optional): the other entity that this hardware component must not be created until their termination. Defaults to None.\n    \"\"\"\n    super().__init__(label, create_at, terminate_at, precursor)\n</code></pre>"},{"location":"api/hardware_component/#PyCloudSim.entity.v_hardware_component.vHardwareComponent.fail","title":"<code>fail(at)</code>","text":"<p>Fail the hardware component</p> Source code in <code>PyCloudSim\\entity\\v_hardware_component.py</code> <pre><code>def fail(self, at: int | float) -&gt; None:\n    \"\"\"Fail the hardware component\"\"\"\n\n    if self.failed:\n        warnings.warn(f\"{self.label} is already failed.\")\n        return\n\n    if self.terminated:\n        warnings.warn(f\"{self.label} is terminated.\")\n        return\n\n    @self.instant_event(at, label=f\"{self.label} Fail\")\n    def _fail() -&gt; None:\n        if self.failed or self.terminated:\n            return\n        self.on_fail()\n        self.power_off(simulation.now)\n        self.state.append(Constants.FAIL)\n</code></pre>"},{"location":"api/hardware_component/#PyCloudSim.entity.v_hardware_component.vHardwareComponent.on_fail","title":"<code>on_fail()</code>","text":"<p>Called when the hardware component fails</p> Source code in <code>PyCloudSim\\entity\\v_hardware_component.py</code> <pre><code>def on_fail(self) -&gt; None:\n    \"\"\"Called when the hardware component fails\"\"\"\n    pass\n</code></pre>"},{"location":"api/hardware_component/#PyCloudSim.entity.v_hardware_component.vHardwareComponent.on_power_off","title":"<code>on_power_off()</code>","text":"<p>Called when the hardware entity is powered off</p> Source code in <code>PyCloudSim\\entity\\v_hardware_component.py</code> <pre><code>def on_power_off(self) -&gt; None:\n    \"\"\"Called when the hardware entity is powered off\"\"\"\n    pass\n</code></pre>"},{"location":"api/hardware_component/#PyCloudSim.entity.v_hardware_component.vHardwareComponent.on_power_on","title":"<code>on_power_on()</code>","text":"<p>Called when the hardware entity is powered on</p> Source code in <code>PyCloudSim\\entity\\v_hardware_component.py</code> <pre><code>def on_power_on(self) -&gt; None:\n    \"\"\"Called when the hardware entity is powered on\"\"\"\n    pass\n</code></pre>"},{"location":"api/hardware_component/#PyCloudSim.entity.v_hardware_component.vHardwareComponent.on_termination","title":"<code>on_termination()</code>","text":"<p>Power off upon termination.</p> Source code in <code>PyCloudSim\\entity\\v_hardware_component.py</code> <pre><code>def on_termination(self):\n    \"\"\"Power off upon termination.\"\"\"\n    self.power_off(simulation.now)\n</code></pre>"},{"location":"api/hardware_component/#PyCloudSim.entity.v_hardware_component.vHardwareComponent.power_off","title":"<code>power_off(at)</code>","text":"<p>Power off the hardware entity</p> Source code in <code>PyCloudSim\\entity\\v_hardware_component.py</code> <pre><code>def power_off(self, at: int | float) -&gt; None:\n    \"\"\"Power off the hardware entity\"\"\"\n\n    if self.powered_off:\n        warnings.warn(f\"{self.label} is already powered off.\")\n        return\n    if self.failed:\n        warnings.warn(f\"{self.label} is failed.\")\n        return\n\n    if self.terminated:\n        warnings.warn(f\"{self.label} is terminated.\")\n        return\n\n    @self.instant_event(at, label=f\"{self.label} Power Off\", priority=-1)\n    def _power_off() -&gt; None:\n        if self.powered_off or self.terminated:\n            return\n        self.on_power_off()\n        self.state.append(Constants.POWER_OFF)\n        if Constants.POWER_ON in self.state:\n            self.state.remove(Constants.POWER_ON)\n</code></pre>"},{"location":"api/hardware_component/#PyCloudSim.entity.v_hardware_component.vHardwareComponent.power_on","title":"<code>power_on(at)</code>","text":"<p>Power on the hardware entity</p> Source code in <code>PyCloudSim\\entity\\v_hardware_component.py</code> <pre><code>def power_on(self, at: int | float) -&gt; None:\n    \"\"\"Power on the hardware entity\"\"\"\n\n    if self.powered_on:\n        warnings.warn(f\"{self.label} is already powered on.\")\n        return\n\n    if self.failed:\n        warnings.warn(f\"{self.label} is failed.\")\n        return\n\n    if self.terminated:\n        warnings.warn(f\"{self.label} is terminated.\")\n        return\n\n    @self.instant_event(at, label=f\"{self.label} Power On\", priority=-1)\n    def _power_on() -&gt; None:\n        if self.powered_on or self.terminated:\n            return\n        self.on_power_on()\n        self.state.append(Constants.POWER_ON)\n        if Constants.POWER_OFF in self.state:\n            self.state.remove(Constants.POWER_OFF)\n        if Constants.FAIL in self.state:\n            self.state.remove(Constants.FAIL)\n</code></pre>"},{"location":"api/hardware_component/v_cpu/","title":"vCPU","text":"<p>The class \"vCPU\" is an implementation derived from the \"PhysicalComponent\" class. A \"vCPU\" object consists of multiple \"vCPUCore\" instances and a cache that serves as a pool for storing \"vProcess\" objects. Whenever a new \"vProcess\" is added to the cache or a \"vProcess\" is terminated, the \"vCPU\" class handles the assignment of \"vProcess\" objects to its corresponding \"vCPUCore\" based on several factors. These factors include the priority of the \"vProcess,\" the available computational power of each \"vCPUCore,\" and the allowed CPU time of the associated \"vContainer.\" Notably, a single \"vProcess\" can be assigned to multiple \"vCPUCore\" instances, allowing for simulated parallel execution. The scheduling of \"vProcess\" is implemented as an event with only one scheduling event being active for each \"vCPU\" at any given time.</p> <p>             Bases: <code>vHardwareComponent</code></p> Source code in <code>PyCloudSim\\entity\\v_cpu.py</code> <pre><code>class vCPU(vHardwareComponent):\n    def __init__(\n        self,\n        ipc: int | Callable,\n        frequency: int | Callable,\n        num_cores: int | Callable,\n        tdp: int | float | Callable,\n        mode: int,\n        host: vHardwareEntity | None = None,\n        label: str | None = None,\n        create_at: int\n        | float\n        | Callable[..., int]\n        | Callable[..., float]\n        | None = None,\n        terminate_at: int\n        | float\n        | Callable[..., int]\n        | Callable[..., float]\n        | None = None,\n        precursor: Entity | List[Entity] | None = None,\n    ) -&gt; None:\n        \"\"\"Create a simulated CPU.\n\n        Args:\n            ipc (int | Callable): the instructions per cycle (IPC) of the CPU core.\n            frequency (int | Callable): the frequency of the CPU core.\n            num_cores (int | Callable): the number of cores of the CPU.\n            tdp (int | float | Callable): the thermal design power (TDP) of the CPU.\n            mode (int): 1 or 2, the mode of the CPU.\n            host (vHardwareEntity | None, optional): the host of this CPU. Defaults to None.\n            label (str | None, optional): the short description of the CPU. Defaults to None.\n            create_at (int | float | Callable[..., int] | Callable[..., float] | None, optional): when this CPU should be created. Defaults to None.\n            terminate_at (int | float | Callable[..., int] | Callable[..., float] | None, optional): when this CPU should be terminated. Defaults to None.\n            precursor (Entity | List[Entity] | None, optional): the entity that this CPU must not be created before. Defaults to None.\n        \"\"\"\n        super().__init__(label, create_at, terminate_at, precursor)\n\n        # assign attributes\n        if callable(ipc):\n            self._ipc = round(ipc())\n        else:\n            self._ipc = ipc\n\n        if callable(frequency):\n            self._frequency = round(frequency())\n        else:\n            self._frequency = frequency\n\n        if callable(num_cores):\n            self._num_cores = round(num_cores())\n        else:\n            self._num_cores = num_cores\n\n        if callable(tdp):\n            self._tdp = tdp()\n        else:\n            self._tdp = tdp\n\n        self._mode = mode\n\n        self._process_queue: List[vProcess | vContainerProcess | vDeamon | vDecoder] = EntityList(label=f\"{self}-Process Queue\")\n        self._cores: List[vCPUCore] = EntityList(label=f\"vCPU {self}_Cores\")\n        self._computational_power_reservoir = Resource(\n            capacity=1000 * self.num_cores,\n            label=f\"{self}-Computational Power Reservoir\",\n        )\n        self._host = host\n\n    def on_creation(self):\n        # create cores\n        for i in range(self._num_cores):\n            self.cores.append(\n                vCPUCore(\n                    self._ipc,\n                    self._frequency,\n                    label=f\"{self.label}-{i}\",\n                    create_at=simulation.now,\n                )\n            )\n\n    def on_termination(self):\n        # terminate cores\n        for core in self._cores[:]:\n            core.terminate(simulation.now)\n\n    def on_power_on(self) -&gt; None:\n        \"\"\"Power on the CPU, also starts the process scheduling.\"\"\"\n        # power on all the cores\n        for core in self.cores:\n            core.power_on(at=simulation.now)\n\n        # start process scheduling\n        @self.continuous_event(\n            at=simulation.now,\n            interval=self.instruction_cycle,\n            duration=inf,\n            label=f\"{self} Scheduling process\",\n        )\n        def _schedule_process():\n            # sort the process queue by priority\n            self.process_queue.sort(key=lambda process: process.priority, reverse=False)\n            for process in self.process_queue:\n                # calculate the number of schedulable instructions\n                if process.container is None:\n                    container_cpu_capacity = inf\n                else:\n                    container_cpu_capacity = round(\n                        ((process.container.cpu_limit - process.container.cpu_usage) / 1000)\n                        * (self.ipc * self.frequency)\n                    )\n                schedulable_instructions = min(\n                    [len(process.unscheduled_instructions), container_cpu_capacity]\n                )\n                if schedulable_instructions &lt;= 0:\n                    continue\n                logger.debug(\n                    f\"{simulation.now}:\\t{self} is executing {schedulable_instructions} instructions of {process}.\"\n                )\n                try:\n                    while schedulable_instructions &gt; 0:\n                        # get and sort available cores\n                        available_cores = [\n                            core\n                            for core in self.cores\n                            if core.computational_power.amount &gt; 0\n                        ]\n                        if len(available_cores) == 0:\n                            break\n                        available_cores.sort(\n                            key=lambda core: core.computational_power.amount,\n                            reverse=True,\n                        )\n                        # mode 1: assign one instruction to one core, then move on to the next core\n                        if self.mode == 1:\n                            core = available_cores[0]\n                            # get the next instruction\n                            instruction = process.unscheduled_instructions.pop(0)\n                            # update the host ram usage\n                            if process.host is None:\n                                raise RuntimeError()\n                            # a value error exception will be raised if fail to distribute the ram space\n                            instruction.get(process.host.ram, instruction.length)\n                            # update the container's ram usage\n                            if process.container is not None:\n                                process.container._ram_usage += instruction.length\n                                # break the loop if container's ram usage exceeds the limit\n                                if (\n                                    process.container.ram_usage\n                                    &gt; process.container.ram_limit\n                                ):\n                                    raise Exception()\n                                # update the container's cpu usage\n                                process.container._cpu_usage += (1 * 1000) / (\n                                    self.ipc * self.frequency\n                                )\n                            # cache the instruction to the core\n                            core.cache_instruction(instruction)\n                            schedulable_instructions -= 1\n                        # mode 2: assign as many instructions as possible to one core, then move on to the next core\n                        elif self.mode == 2:\n                            core = available_cores[0]\n                            for _ in range(\n                                round(\n                                    min(\n                                        [\n                                            schedulable_instructions,\n                                            core.computational_power.amount,\n                                        ]\n                                    )\n                                )\n                            ):\n                                # get the next instruction\n                                instruction = process.unscheduled_instructions.pop(0)\n                                # update the host ram usage\n                                if process.host is None:\n                                    raise RuntimeError()\n                                # a value error exception will be raised if fail to distribute the ram space\n                                instruction.get(process.host.ram, instruction.length)\n                                if process.container is not None:\n                                    # update the container's ram usage\n                                    process.container._ram_usage += instruction.length\n                                    # break the loop if container's ram usage exceeds the limit\n                                    if (\n                                        process.container.ram_usage\n                                        &gt; process.container.ram_limit\n                                    ):\n                                        raise Exception()\n                                    # update the container's cpu usage\n                                    process.container._cpu_usage += (1 * 1000) / (\n                                        self.ipc * self.frequency\n                                    )\n                                # cache the instruction to the core\n                                core.cache_instruction(instruction)\n                                schedulable_instructions -= 1\n                except Exception:\n                    process.fail(simulation.now)\n                    if process.container is not None:\n                        process.container.fail(simulation.now)\n                    continue                   \n\n    def on_power_off(self) -&gt; None:\n        \"\"\"Power off the CPU, also terminates all unfinished processes.\"\"\"\n        # terminate all unfinished processes\n        for process in self.process_queue:\n            process.fail(simulation.now)\n\n        # power off all the cores\n        for core in self.cores:\n            core.power_off(at=simulation.now)\n\n        # cancel process scheduling\n        for event in self.events:\n            if event.label == f\"{self} Scheduling process\":\n                event.cancel()\n\n    def on_fail(self) -&gt; None:\n        self.power_off(simulation.now)\n\n    @property\n    def ipc(self) -&gt; int:\n        \"\"\"Returns the number of instructions per cycle (IPC) of the CPU core.\"\"\"\n        return self._ipc\n\n    @property\n    def frequency(self) -&gt; int:\n        \"\"\"Returns the frequency of the CPU core.\"\"\"\n        return self._frequency\n\n    @property\n    def num_cores(self) -&gt; int:\n        \"\"\"Returns the number of CPU cores.\"\"\"\n        return self._num_cores\n\n    @property\n    def tdp(self) -&gt; int | float:\n        \"\"\"Returns the thermal design power (TDP) of the CPU.\"\"\"\n        return self._tdp\n\n    @property\n    def computational_power_reservoir(self) -&gt; Resource:\n        \"\"\"Returns the computational power reservoir of the CPU.\"\"\"\n        return self._computational_power_reservoir\n\n    @property\n    def process_queue(self):\n        \"\"\"Returns the process queue of the CPU.\"\"\"\n        return self._process_queue\n\n    @property\n    def cores(self):\n        \"\"\"Returns the cores of the CPU.\"\"\"\n        return self._cores\n\n    @property\n    def host(self):\n        \"\"\"Returns the host of the CPU.\"\"\"\n        return self._host\n\n    @property\n    def mode(self):\n        \"\"\"Returns the mode of the CPU.\"\"\"\n        return self._mode\n\n    @property\n    def instruction_cycle(self):\n        \"\"\"Returns the instruction cycle of the CPU.\"\"\"\n        return 1 / (self.ipc * self.frequency)\n\n    def usage(self, duration: int | float | None = None):\n        \"\"\"Returns the CPU usage.\"\"\"\n        return sum([core.usage(duration) for core in self.cores])\n\n    def utilization(self, duration: int | float | None = None):\n        \"\"\"Returns the CPU utilization.\"\"\"\n        return sum([core.utilization(duration) for core in self.cores]) / len(\n            self.cores\n        )\n</code></pre>"},{"location":"api/hardware_component/v_cpu/#PyCloudSim.entity.v_cpu.vCPU.computational_power_reservoir","title":"<code>computational_power_reservoir: Resource</code>  <code>property</code>","text":"<p>Returns the computational power reservoir of the CPU.</p>"},{"location":"api/hardware_component/v_cpu/#PyCloudSim.entity.v_cpu.vCPU.cores","title":"<code>cores</code>  <code>property</code>","text":"<p>Returns the cores of the CPU.</p>"},{"location":"api/hardware_component/v_cpu/#PyCloudSim.entity.v_cpu.vCPU.frequency","title":"<code>frequency: int</code>  <code>property</code>","text":"<p>Returns the frequency of the CPU core.</p>"},{"location":"api/hardware_component/v_cpu/#PyCloudSim.entity.v_cpu.vCPU.host","title":"<code>host</code>  <code>property</code>","text":"<p>Returns the host of the CPU.</p>"},{"location":"api/hardware_component/v_cpu/#PyCloudSim.entity.v_cpu.vCPU.instruction_cycle","title":"<code>instruction_cycle</code>  <code>property</code>","text":"<p>Returns the instruction cycle of the CPU.</p>"},{"location":"api/hardware_component/v_cpu/#PyCloudSim.entity.v_cpu.vCPU.ipc","title":"<code>ipc: int</code>  <code>property</code>","text":"<p>Returns the number of instructions per cycle (IPC) of the CPU core.</p>"},{"location":"api/hardware_component/v_cpu/#PyCloudSim.entity.v_cpu.vCPU.mode","title":"<code>mode</code>  <code>property</code>","text":"<p>Returns the mode of the CPU.</p>"},{"location":"api/hardware_component/v_cpu/#PyCloudSim.entity.v_cpu.vCPU.num_cores","title":"<code>num_cores: int</code>  <code>property</code>","text":"<p>Returns the number of CPU cores.</p>"},{"location":"api/hardware_component/v_cpu/#PyCloudSim.entity.v_cpu.vCPU.process_queue","title":"<code>process_queue</code>  <code>property</code>","text":"<p>Returns the process queue of the CPU.</p>"},{"location":"api/hardware_component/v_cpu/#PyCloudSim.entity.v_cpu.vCPU.tdp","title":"<code>tdp: int | float</code>  <code>property</code>","text":"<p>Returns the thermal design power (TDP) of the CPU.</p>"},{"location":"api/hardware_component/v_cpu/#PyCloudSim.entity.v_cpu.vCPU.__init__","title":"<code>__init__(ipc, frequency, num_cores, tdp, mode, host=None, label=None, create_at=None, terminate_at=None, precursor=None)</code>","text":"<p>Create a simulated CPU.</p> <p>Parameters:</p> Name Type Description Default <code>ipc</code> <code>int | Callable</code> <p>the instructions per cycle (IPC) of the CPU core.</p> required <code>frequency</code> <code>int | Callable</code> <p>the frequency of the CPU core.</p> required <code>num_cores</code> <code>int | Callable</code> <p>the number of cores of the CPU.</p> required <code>tdp</code> <code>int | float | Callable</code> <p>the thermal design power (TDP) of the CPU.</p> required <code>mode</code> <code>int</code> <p>1 or 2, the mode of the CPU.</p> required <code>host</code> <code>vHardwareEntity | None</code> <p>the host of this CPU. Defaults to None.</p> <code>None</code> <code>label</code> <code>str | None</code> <p>the short description of the CPU. Defaults to None.</p> <code>None</code> <code>create_at</code> <code>int | float | Callable[..., int] | Callable[..., float] | None</code> <p>when this CPU should be created. Defaults to None.</p> <code>None</code> <code>terminate_at</code> <code>int | float | Callable[..., int] | Callable[..., float] | None</code> <p>when this CPU should be terminated. Defaults to None.</p> <code>None</code> <code>precursor</code> <code>Entity | List[Entity] | None</code> <p>the entity that this CPU must not be created before. Defaults to None.</p> <code>None</code> Source code in <code>PyCloudSim\\entity\\v_cpu.py</code> <pre><code>def __init__(\n    self,\n    ipc: int | Callable,\n    frequency: int | Callable,\n    num_cores: int | Callable,\n    tdp: int | float | Callable,\n    mode: int,\n    host: vHardwareEntity | None = None,\n    label: str | None = None,\n    create_at: int\n    | float\n    | Callable[..., int]\n    | Callable[..., float]\n    | None = None,\n    terminate_at: int\n    | float\n    | Callable[..., int]\n    | Callable[..., float]\n    | None = None,\n    precursor: Entity | List[Entity] | None = None,\n) -&gt; None:\n    \"\"\"Create a simulated CPU.\n\n    Args:\n        ipc (int | Callable): the instructions per cycle (IPC) of the CPU core.\n        frequency (int | Callable): the frequency of the CPU core.\n        num_cores (int | Callable): the number of cores of the CPU.\n        tdp (int | float | Callable): the thermal design power (TDP) of the CPU.\n        mode (int): 1 or 2, the mode of the CPU.\n        host (vHardwareEntity | None, optional): the host of this CPU. Defaults to None.\n        label (str | None, optional): the short description of the CPU. Defaults to None.\n        create_at (int | float | Callable[..., int] | Callable[..., float] | None, optional): when this CPU should be created. Defaults to None.\n        terminate_at (int | float | Callable[..., int] | Callable[..., float] | None, optional): when this CPU should be terminated. Defaults to None.\n        precursor (Entity | List[Entity] | None, optional): the entity that this CPU must not be created before. Defaults to None.\n    \"\"\"\n    super().__init__(label, create_at, terminate_at, precursor)\n\n    # assign attributes\n    if callable(ipc):\n        self._ipc = round(ipc())\n    else:\n        self._ipc = ipc\n\n    if callable(frequency):\n        self._frequency = round(frequency())\n    else:\n        self._frequency = frequency\n\n    if callable(num_cores):\n        self._num_cores = round(num_cores())\n    else:\n        self._num_cores = num_cores\n\n    if callable(tdp):\n        self._tdp = tdp()\n    else:\n        self._tdp = tdp\n\n    self._mode = mode\n\n    self._process_queue: List[vProcess | vContainerProcess | vDeamon | vDecoder] = EntityList(label=f\"{self}-Process Queue\")\n    self._cores: List[vCPUCore] = EntityList(label=f\"vCPU {self}_Cores\")\n    self._computational_power_reservoir = Resource(\n        capacity=1000 * self.num_cores,\n        label=f\"{self}-Computational Power Reservoir\",\n    )\n    self._host = host\n</code></pre>"},{"location":"api/hardware_component/v_cpu/#PyCloudSim.entity.v_cpu.vCPU.on_power_off","title":"<code>on_power_off()</code>","text":"<p>Power off the CPU, also terminates all unfinished processes.</p> Source code in <code>PyCloudSim\\entity\\v_cpu.py</code> <pre><code>def on_power_off(self) -&gt; None:\n    \"\"\"Power off the CPU, also terminates all unfinished processes.\"\"\"\n    # terminate all unfinished processes\n    for process in self.process_queue:\n        process.fail(simulation.now)\n\n    # power off all the cores\n    for core in self.cores:\n        core.power_off(at=simulation.now)\n\n    # cancel process scheduling\n    for event in self.events:\n        if event.label == f\"{self} Scheduling process\":\n            event.cancel()\n</code></pre>"},{"location":"api/hardware_component/v_cpu/#PyCloudSim.entity.v_cpu.vCPU.on_power_on","title":"<code>on_power_on()</code>","text":"<p>Power on the CPU, also starts the process scheduling.</p> Source code in <code>PyCloudSim\\entity\\v_cpu.py</code> <pre><code>def on_power_on(self) -&gt; None:\n    \"\"\"Power on the CPU, also starts the process scheduling.\"\"\"\n    # power on all the cores\n    for core in self.cores:\n        core.power_on(at=simulation.now)\n\n    # start process scheduling\n    @self.continuous_event(\n        at=simulation.now,\n        interval=self.instruction_cycle,\n        duration=inf,\n        label=f\"{self} Scheduling process\",\n    )\n    def _schedule_process():\n        # sort the process queue by priority\n        self.process_queue.sort(key=lambda process: process.priority, reverse=False)\n        for process in self.process_queue:\n            # calculate the number of schedulable instructions\n            if process.container is None:\n                container_cpu_capacity = inf\n            else:\n                container_cpu_capacity = round(\n                    ((process.container.cpu_limit - process.container.cpu_usage) / 1000)\n                    * (self.ipc * self.frequency)\n                )\n            schedulable_instructions = min(\n                [len(process.unscheduled_instructions), container_cpu_capacity]\n            )\n            if schedulable_instructions &lt;= 0:\n                continue\n            logger.debug(\n                f\"{simulation.now}:\\t{self} is executing {schedulable_instructions} instructions of {process}.\"\n            )\n            try:\n                while schedulable_instructions &gt; 0:\n                    # get and sort available cores\n                    available_cores = [\n                        core\n                        for core in self.cores\n                        if core.computational_power.amount &gt; 0\n                    ]\n                    if len(available_cores) == 0:\n                        break\n                    available_cores.sort(\n                        key=lambda core: core.computational_power.amount,\n                        reverse=True,\n                    )\n                    # mode 1: assign one instruction to one core, then move on to the next core\n                    if self.mode == 1:\n                        core = available_cores[0]\n                        # get the next instruction\n                        instruction = process.unscheduled_instructions.pop(0)\n                        # update the host ram usage\n                        if process.host is None:\n                            raise RuntimeError()\n                        # a value error exception will be raised if fail to distribute the ram space\n                        instruction.get(process.host.ram, instruction.length)\n                        # update the container's ram usage\n                        if process.container is not None:\n                            process.container._ram_usage += instruction.length\n                            # break the loop if container's ram usage exceeds the limit\n                            if (\n                                process.container.ram_usage\n                                &gt; process.container.ram_limit\n                            ):\n                                raise Exception()\n                            # update the container's cpu usage\n                            process.container._cpu_usage += (1 * 1000) / (\n                                self.ipc * self.frequency\n                            )\n                        # cache the instruction to the core\n                        core.cache_instruction(instruction)\n                        schedulable_instructions -= 1\n                    # mode 2: assign as many instructions as possible to one core, then move on to the next core\n                    elif self.mode == 2:\n                        core = available_cores[0]\n                        for _ in range(\n                            round(\n                                min(\n                                    [\n                                        schedulable_instructions,\n                                        core.computational_power.amount,\n                                    ]\n                                )\n                            )\n                        ):\n                            # get the next instruction\n                            instruction = process.unscheduled_instructions.pop(0)\n                            # update the host ram usage\n                            if process.host is None:\n                                raise RuntimeError()\n                            # a value error exception will be raised if fail to distribute the ram space\n                            instruction.get(process.host.ram, instruction.length)\n                            if process.container is not None:\n                                # update the container's ram usage\n                                process.container._ram_usage += instruction.length\n                                # break the loop if container's ram usage exceeds the limit\n                                if (\n                                    process.container.ram_usage\n                                    &gt; process.container.ram_limit\n                                ):\n                                    raise Exception()\n                                # update the container's cpu usage\n                                process.container._cpu_usage += (1 * 1000) / (\n                                    self.ipc * self.frequency\n                                )\n                            # cache the instruction to the core\n                            core.cache_instruction(instruction)\n                            schedulable_instructions -= 1\n            except Exception:\n                process.fail(simulation.now)\n                if process.container is not None:\n                    process.container.fail(simulation.now)\n                continue                   \n</code></pre>"},{"location":"api/hardware_component/v_cpu/#PyCloudSim.entity.v_cpu.vCPU.usage","title":"<code>usage(duration=None)</code>","text":"<p>Returns the CPU usage.</p> Source code in <code>PyCloudSim\\entity\\v_cpu.py</code> <pre><code>def usage(self, duration: int | float | None = None):\n    \"\"\"Returns the CPU usage.\"\"\"\n    return sum([core.usage(duration) for core in self.cores])\n</code></pre>"},{"location":"api/hardware_component/v_cpu/#PyCloudSim.entity.v_cpu.vCPU.utilization","title":"<code>utilization(duration=None)</code>","text":"<p>Returns the CPU utilization.</p> Source code in <code>PyCloudSim\\entity\\v_cpu.py</code> <pre><code>def utilization(self, duration: int | float | None = None):\n    \"\"\"Returns the CPU utilization.\"\"\"\n    return sum([core.utilization(duration) for core in self.cores]) / len(\n        self.cores\n    )\n</code></pre>"},{"location":"api/hardware_component/v_cpu_core/","title":"vCPUCore","text":"<p>The class \"vCPUCore\" serves as the implementation of CPU cores within the simulation. It includes two mandatory attributes: frequency and instructions-per-cycle, which determine the computational capacity of the core. The computational capacity is represented as a \"Resource\" object from the \"Akatosh\" library, enabling withdrawal or return of the available amount during the simulation. The \"vCPUCore\" is responsible for allocating the computational power to the assigned processes and reclaiming the distributed amount once the execution of the assigned process is complete. In the event that the \"vCPUCore\" is arbitrarily powered off during the simulation, all processes currently in execution will be considered as failed.</p> <p>             Bases: <code>vHardwareComponent</code></p> Source code in <code>PyCloudSim\\entity\\v_cpu_core.py</code> <pre><code>class vCPUCore(vHardwareComponent):\n    def __init__(\n        self,\n        ipc: int | Callable,\n        frequency: int | Callable,\n        label: str | None = None,\n        create_at: int | float | Callable[..., Any] | None = None,\n        terminate_at: int | float | Callable[..., Any] | None = None,\n        precursor: Entity | List[Entity] | None = None,\n    ) -&gt; None:\n        \"\"\"Create a simulated CPU core.\n\n        Args:\n            ipc (int | Callable): instructions per cycle.\n            frequency (int | Callable): the frequency of the CPU core.\n            label (str | None, optional): the short description of the CPU Core. Defaults to None.\n            create_at (int | float | Callable[..., Any] | None, optional): when this CPU core should be created. Defaults to None.\n            terminate_at (int | float | Callable[..., Any] | None, optional): when this CPU core should be terminated. Defaults to None.\n            precursor (Entity | List[Entity] | None, optional): the entity that this CPU core must not be created before. Defaults to None.\n        \"\"\"\n        super().__init__(label, create_at, terminate_at, precursor)\n\n        if callable(ipc):\n            self._ipc = round(ipc())\n        else:\n            self._ipc = ipc\n\n        if callable(frequency):\n            self._frequency = round(frequency())\n        else:\n            self._frequency = frequency\n        self._instruction_cycle = 1 / (self._ipc * self._frequency)\n        self._computational_power = Resource(\n            capacity=self.ipc * self.frequency,\n            label=f\"{self} Computational Power\",\n        )\n        self._instructions_queue: List[vInstruction] = EntityList(\n            label=f\"{self} InstructionsQueue\"\n        )\n        self._clock: Event = None  # type: ignore\n\n    def on_power_on(self):\n        \"\"\"Create the execution clock of the CPU core.\"\"\"\n\n        @self.continuous_event(\n            at=simulation.now + self.instruction_cycle,\n            interval=self.instruction_cycle,\n            duration=inf,\n            label=f\"{self.label} Clock\",\n        )\n        def _execute_instruction():\n            if len(self.instructions_queue) &gt; 0:\n                instruction = self.instructions_queue[0]\n                instruction.terminate(at=simulation.now)\n                logger.debug(\n                    f\"{simulation.now}:\\t{self} executed {instruction}, current capacity: {self.computational_power.amount}, queue length: {len(self.instructions_queue)}.\"\n                )\n                if instruction.process.deamon:\n                    instruction = vInstruction(\n                        process=instruction.process,\n                        create_at=simulation.now,\n                    )\n\n    def cache_instruction(self, instruction: vInstruction) -&gt; None:\n        \"\"\"Cache instructions from a process to the CPU core.\"\"\"\n        self.instructions_queue.append(instruction)\n        instruction.get(self.computational_power, 1)\n\n    def on_power_off(self) -&gt; None:\n        \"\"\"Power off the CPU core.\"\"\"\n        # terminate the clock of the CPU core.\n        for event in self.events:\n            if event.label == f\"{self.label} Clock\":\n                event.cancel()\n\n        # find impacted process.\n        impacted_process: List[vProcess] = []\n        for instruction in self.instructions_queue:\n            if instruction.process not in impacted_process:\n                impacted_process.append(instruction.process)\n        # fail impacted process.\n        for process in impacted_process:\n            process.fail(simulation.now)\n\n    def on_fail(self) -&gt; None:\n        self.power_off(simulation.now)\n\n    @property\n    def ipc(self) -&gt; int:\n        \"\"\"Returns the number of instructions per cycle of the CPU core.\"\"\"\n        return self._ipc\n\n    @property\n    def frequency(self) -&gt; int:\n        \"\"\"Returns the frequency of the CPU core.\"\"\"\n        return self._frequency\n\n    @property\n    def instruction_cycle(self) -&gt; float:\n        \"\"\"Returns the time taken to execute one instruction.\"\"\"\n        return self._instruction_cycle\n\n    @property\n    def instructions_queue(self):\n        \"\"\"Returns the instructions queue of the CPU core.\"\"\"\n        return self._instructions_queue\n\n    @property\n    def computational_power(self) -&gt; Resource:\n        \"\"\"Returns the computational power of the CPU core.\"\"\"\n        return self._computational_power\n\n    @property\n    def clock(self):\n        \"\"\"Returns the clock of the CPU core, which is the continuous event that consumes instructions.\"\"\"\n        return self._clock\n\n    def usage(self, duration: int | float | None = None):\n        \"\"\"Returns the usage of the CPU core.\"\"\"\n        return self.computational_power.usage(duration)\n\n    def utilization(self, duration: int | float | None = None):\n        \"\"\"Returns the utilization of the CPU core.\"\"\"\n        return self.computational_power.utilization(duration)\n</code></pre>"},{"location":"api/hardware_component/v_cpu_core/#PyCloudSim.entity.v_cpu_core.vCPUCore.clock","title":"<code>clock</code>  <code>property</code>","text":"<p>Returns the clock of the CPU core, which is the continuous event that consumes instructions.</p>"},{"location":"api/hardware_component/v_cpu_core/#PyCloudSim.entity.v_cpu_core.vCPUCore.computational_power","title":"<code>computational_power: Resource</code>  <code>property</code>","text":"<p>Returns the computational power of the CPU core.</p>"},{"location":"api/hardware_component/v_cpu_core/#PyCloudSim.entity.v_cpu_core.vCPUCore.frequency","title":"<code>frequency: int</code>  <code>property</code>","text":"<p>Returns the frequency of the CPU core.</p>"},{"location":"api/hardware_component/v_cpu_core/#PyCloudSim.entity.v_cpu_core.vCPUCore.instruction_cycle","title":"<code>instruction_cycle: float</code>  <code>property</code>","text":"<p>Returns the time taken to execute one instruction.</p>"},{"location":"api/hardware_component/v_cpu_core/#PyCloudSim.entity.v_cpu_core.vCPUCore.instructions_queue","title":"<code>instructions_queue</code>  <code>property</code>","text":"<p>Returns the instructions queue of the CPU core.</p>"},{"location":"api/hardware_component/v_cpu_core/#PyCloudSim.entity.v_cpu_core.vCPUCore.ipc","title":"<code>ipc: int</code>  <code>property</code>","text":"<p>Returns the number of instructions per cycle of the CPU core.</p>"},{"location":"api/hardware_component/v_cpu_core/#PyCloudSim.entity.v_cpu_core.vCPUCore.__init__","title":"<code>__init__(ipc, frequency, label=None, create_at=None, terminate_at=None, precursor=None)</code>","text":"<p>Create a simulated CPU core.</p> <p>Parameters:</p> Name Type Description Default <code>ipc</code> <code>int | Callable</code> <p>instructions per cycle.</p> required <code>frequency</code> <code>int | Callable</code> <p>the frequency of the CPU core.</p> required <code>label</code> <code>str | None</code> <p>the short description of the CPU Core. Defaults to None.</p> <code>None</code> <code>create_at</code> <code>int | float | Callable[..., Any] | None</code> <p>when this CPU core should be created. Defaults to None.</p> <code>None</code> <code>terminate_at</code> <code>int | float | Callable[..., Any] | None</code> <p>when this CPU core should be terminated. Defaults to None.</p> <code>None</code> <code>precursor</code> <code>Entity | List[Entity] | None</code> <p>the entity that this CPU core must not be created before. Defaults to None.</p> <code>None</code> Source code in <code>PyCloudSim\\entity\\v_cpu_core.py</code> <pre><code>def __init__(\n    self,\n    ipc: int | Callable,\n    frequency: int | Callable,\n    label: str | None = None,\n    create_at: int | float | Callable[..., Any] | None = None,\n    terminate_at: int | float | Callable[..., Any] | None = None,\n    precursor: Entity | List[Entity] | None = None,\n) -&gt; None:\n    \"\"\"Create a simulated CPU core.\n\n    Args:\n        ipc (int | Callable): instructions per cycle.\n        frequency (int | Callable): the frequency of the CPU core.\n        label (str | None, optional): the short description of the CPU Core. Defaults to None.\n        create_at (int | float | Callable[..., Any] | None, optional): when this CPU core should be created. Defaults to None.\n        terminate_at (int | float | Callable[..., Any] | None, optional): when this CPU core should be terminated. Defaults to None.\n        precursor (Entity | List[Entity] | None, optional): the entity that this CPU core must not be created before. Defaults to None.\n    \"\"\"\n    super().__init__(label, create_at, terminate_at, precursor)\n\n    if callable(ipc):\n        self._ipc = round(ipc())\n    else:\n        self._ipc = ipc\n\n    if callable(frequency):\n        self._frequency = round(frequency())\n    else:\n        self._frequency = frequency\n    self._instruction_cycle = 1 / (self._ipc * self._frequency)\n    self._computational_power = Resource(\n        capacity=self.ipc * self.frequency,\n        label=f\"{self} Computational Power\",\n    )\n    self._instructions_queue: List[vInstruction] = EntityList(\n        label=f\"{self} InstructionsQueue\"\n    )\n    self._clock: Event = None  # type: ignore\n</code></pre>"},{"location":"api/hardware_component/v_cpu_core/#PyCloudSim.entity.v_cpu_core.vCPUCore.cache_instruction","title":"<code>cache_instruction(instruction)</code>","text":"<p>Cache instructions from a process to the CPU core.</p> Source code in <code>PyCloudSim\\entity\\v_cpu_core.py</code> <pre><code>def cache_instruction(self, instruction: vInstruction) -&gt; None:\n    \"\"\"Cache instructions from a process to the CPU core.\"\"\"\n    self.instructions_queue.append(instruction)\n    instruction.get(self.computational_power, 1)\n</code></pre>"},{"location":"api/hardware_component/v_cpu_core/#PyCloudSim.entity.v_cpu_core.vCPUCore.on_power_off","title":"<code>on_power_off()</code>","text":"<p>Power off the CPU core.</p> Source code in <code>PyCloudSim\\entity\\v_cpu_core.py</code> <pre><code>def on_power_off(self) -&gt; None:\n    \"\"\"Power off the CPU core.\"\"\"\n    # terminate the clock of the CPU core.\n    for event in self.events:\n        if event.label == f\"{self.label} Clock\":\n            event.cancel()\n\n    # find impacted process.\n    impacted_process: List[vProcess] = []\n    for instruction in self.instructions_queue:\n        if instruction.process not in impacted_process:\n            impacted_process.append(instruction.process)\n    # fail impacted process.\n    for process in impacted_process:\n        process.fail(simulation.now)\n</code></pre>"},{"location":"api/hardware_component/v_cpu_core/#PyCloudSim.entity.v_cpu_core.vCPUCore.on_power_on","title":"<code>on_power_on()</code>","text":"<p>Create the execution clock of the CPU core.</p> Source code in <code>PyCloudSim\\entity\\v_cpu_core.py</code> <pre><code>def on_power_on(self):\n    \"\"\"Create the execution clock of the CPU core.\"\"\"\n\n    @self.continuous_event(\n        at=simulation.now + self.instruction_cycle,\n        interval=self.instruction_cycle,\n        duration=inf,\n        label=f\"{self.label} Clock\",\n    )\n    def _execute_instruction():\n        if len(self.instructions_queue) &gt; 0:\n            instruction = self.instructions_queue[0]\n            instruction.terminate(at=simulation.now)\n            logger.debug(\n                f\"{simulation.now}:\\t{self} executed {instruction}, current capacity: {self.computational_power.amount}, queue length: {len(self.instructions_queue)}.\"\n            )\n            if instruction.process.deamon:\n                instruction = vInstruction(\n                    process=instruction.process,\n                    create_at=simulation.now,\n                )\n</code></pre>"},{"location":"api/hardware_component/v_cpu_core/#PyCloudSim.entity.v_cpu_core.vCPUCore.usage","title":"<code>usage(duration=None)</code>","text":"<p>Returns the usage of the CPU core.</p> Source code in <code>PyCloudSim\\entity\\v_cpu_core.py</code> <pre><code>def usage(self, duration: int | float | None = None):\n    \"\"\"Returns the usage of the CPU core.\"\"\"\n    return self.computational_power.usage(duration)\n</code></pre>"},{"location":"api/hardware_component/v_cpu_core/#PyCloudSim.entity.v_cpu_core.vCPUCore.utilization","title":"<code>utilization(duration=None)</code>","text":"<p>Returns the utilization of the CPU core.</p> Source code in <code>PyCloudSim\\entity\\v_cpu_core.py</code> <pre><code>def utilization(self, duration: int | float | None = None):\n    \"\"\"Returns the utilization of the CPU core.\"\"\"\n    return self.computational_power.utilization(duration)\n</code></pre>"},{"location":"api/hardware_component/v_cpu_core/#usage-example","title":"Usage Example","text":"<pre><code>from PyCloudSim.entity import vCPUCore\ncore = vCPUCore(\n        1, #IPC\n        4000, #Frequency in Mhz\n        \"Core 0\", # Label\n        0, # Created at 0s\n    )\n# power on CPU core\ncore.power_on(at=0)\n# power off CPU core\ncore.powere_off(at=10)\n# terminate the CPU core\ncore.terminate(at=12)\n</code></pre>"},{"location":"api/hardware_component/v_nic/","title":"vNIC","text":"<p>The class \"vNIC\" serves as the implementation of the network interface card in the simulation. It includes a queue specifically designed to store \"vPacket\" objects and has the capability to establish connections with other \"vNIC\" instances. The \"vNIC\" class is equipped with two resources: uplink bandwidth and downlink bandwidth. These resources are allocated to the transmission and reception of \"vPacket\" objects respectively. The transmission and reception functionalities of \"vPacket\" are implemented as member functions within the class. Upon receiving a \"vPacket\", a specialized \"vProcess\" called PacketHandler is created to simulate the decoding process and the associated processing delay. If there is insufficient uplink or downlink bandwidth available, the \"vPacket\" will be kept in the queue until the necessary resources become available.</p> <p>             Bases: <code>vHardwareComponent</code></p> Source code in <code>PyCloudSim\\entity\\v_nic.py</code> <pre><code>class vNIC(vHardwareComponent):\n    def __init__(\n        self,\n        host: vHardwareEntity | vGateway,\n        label: str | None = None,\n        create_at: int\n        | float\n        | Callable[..., int]\n        | Callable[..., float]\n        | None = None,\n        terminate_at: int\n        | float\n        | Callable[..., int]\n        | Callable[..., float]\n        | None = None,\n        precursor: Entity | List[Entity] | None = None,\n    ) -&gt; None:\n        \"\"\"Create a simulated NIC.\"\"\"\n        super().__init__(label, create_at, terminate_at, precursor)\n        self._host = host\n        self._ports: List[vPort] = EntityList(label=f\"{self} Ports\")\n        self._packet_queue: List[vPacket] = EntityList(label=f\"{self} Packet Queue\")\n\n    def on_power_on(self) -&gt; None:\n        \"\"\"Power on the simulated NIC.\"\"\"\n        super().on_power_on()\n        for port in self.ports:\n            port.power_on(simulation.now)\n\n        @self.continuous_event(\n            at=simulation.now,\n            interval=simulation.min_time_unit,\n            duration=inf,\n            label=f\"{self} Transmit Packets\",\n        )\n        def _schedule_packets():\n            \"\"\"A continous event to schedule packets in the queue.\"\"\"\n            self.packet_queue.sort(key=lambda packet: packet.priority)\n            for packet in self.packet_queue:\n                # check if packet is decoded\n                if packet.decoded and not packet.in_transmission:\n                    logger.debug(f\"{simulation.now}:\\t{self} is scheduling {packet}.\")\n                    # find the port to transmit the packet to the next hop\n                    try:\n                        src_port = [\n                            port\n                            for port in self.ports\n                            if port.endpoint is packet.next_hop\n                        ][0]\n                    except:\n                        raise RuntimeError(\n                            f\"Can not find a port on {packet.path[0]} to transmit {packet}.\"\n                        )\n                    # find the port to receive the packet on the next hop\n                    try:\n                        dst_port = [\n                            port\n                            for port in packet.next_hop.NIC.ports\n                            if port.endpoint is packet.current_hop\n                        ][0]\n                    except:\n                        raise RuntimeError(\n                            f\"Can not find a port on {packet.path[1]} to receive {packet}.\"\n                        )\n                    logger.debug(\n                        f\"{simulation.now}:\\t{self} found src port {src_port} and dst port {dst_port} for {packet}\"\n                    )\n                    # calculate the available bandwidth and transmission time\n                    available_bandwidth = min(\n                        src_port.bandwidth.amount, dst_port.bandwidth.amount\n                    )\n                    logger.debug(\n                        f\"{simulation.now}:\\t{self} found available bandwidth {available_bandwidth} for {packet}\"\n                    )\n                    # check if the packet can be transmitted\n                    if available_bandwidth &gt; packet.size:\n                        packet.state.append(Constants.INTRANSMISSION)\n                        link_speed = min(\n                            src_port.bandwidth.capacity, dst_port.bandwidth.capacity\n                        )\n                        # calculate the transmission time\n                        transmission_time = packet.size / link_speed\n\n                        # packet consumes the bandwidth of the src port and returns the bandwidth in future\n                        src_port.transmit(packet, transmission_time)\n\n                        # packet consumes the bandwidth of the dst port and returns the bandwidth in future\n                        dst_port.receive(packet, transmission_time)\n\n                        logger.info(\n                            f\"{simulation.now}:\\t{packet} in transmission from {src_port.host} to {dst_port.host}\"\n                        )\n                else:\n                    # pass packets that have not been decoded\n                    pass\n\n    def on_power_off(self) -&gt; None:\n        \"\"\"Power off the simulated NIC.\"\"\"\n        super().on_power_off()\n        for event in self.events:\n            if event.label == f\"{self} Transmit Packets\":\n                event.cancel()\n\n    def add_port(\n        self,\n        endpoint: vHardwareEntity | vGateway,\n        bandwidth: int | Callable[..., int],\n        ip_address: IPv4Address | None,\n        at: int | float,\n    ):\n        \"\"\"Add a port to this virtual NIC.\"\"\"\n\n        @self.instant_event(at, label=f\"{self} Add Port to {endpoint}\")\n        def _add_port():\n            port = vPort(\n                self,\n                endpoint,\n                bandwidth,\n                ip_address=ip_address,\n                label=f\"{self.label}-{len(self.ports)}\",\n                create_at=simulation.now,\n            )\n            self.ports.append(port)\n\n    def remove_port(self, endpoint: vHardwareEntity, at: int | float):\n        \"\"\"Remove a port from this virtual NIC.\"\"\"\n\n        @self.instant_event(at, label=f\"{self} Remove Port to {endpoint}\")\n        def _remove_port():\n            for port in self.ports:\n                if port.endpoint is endpoint:\n                    port.terminate(simulation.now)\n\n    @property\n    def host(self):\n        \"\"\"Return the host of this NIC.\"\"\"\n        return self._host\n\n    @property\n    def ports(self):\n        \"\"\"Return the ports of this NIC.\"\"\"\n        return self._ports\n\n    @property\n    def packet_queue(self):\n        \"\"\"Return the packet queue of this NIC.\"\"\"\n        return self._packet_queue\n\n    def egress_usage(self, duration: int | float | None = None):\n        \"\"\"Return the egress bandwidth usage of this NIC.\"\"\"\n        return sum([port.usage(duration) for port in self.ports])\n\n    def egress_utilization(self, duration: int | float | None = None):\n        \"\"\"Return the egress bandwidth utilization of this NIC.\"\"\"\n        return sum([port.utilization(duration) for port in self.ports]) / len(\n            self.ports\n        )\n\n    def ingress_usage(self, duration: int | float | None = None):\n        \"\"\"Return the ingress bandwidth usage of this NIC.\"\"\"\n        connected_nodes = [\n            port.endpoint for port in self.ports\n        ]\n        ingress_usage = 0\n        for node in connected_nodes:\n            for port in node.NIC.ports:\n                if port.endpoint is self.host:\n                    ingress_usage += port.usage(duration)\n        return ingress_usage\n\n    def ingress_utilization(self, duration: int | float | None = None):\n        \"\"\"Return the ingress bandwidth utilization of this NIC.\"\"\"\n        connected_nodes = [\n            port.endpoint for port in self.ports\n        ]\n        ingress_utilization = 0\n        for node in connected_nodes:\n            for port in node.NIC.ports:\n                if port.endpoint is self.host:\n                    ingress_utilization += port.utilization(duration)\n        return ingress_utilization / len(connected_nodes)\n</code></pre>"},{"location":"api/hardware_component/v_nic/#PyCloudSim.entity.v_nic.vNIC.host","title":"<code>host</code>  <code>property</code>","text":"<p>Return the host of this NIC.</p>"},{"location":"api/hardware_component/v_nic/#PyCloudSim.entity.v_nic.vNIC.packet_queue","title":"<code>packet_queue</code>  <code>property</code>","text":"<p>Return the packet queue of this NIC.</p>"},{"location":"api/hardware_component/v_nic/#PyCloudSim.entity.v_nic.vNIC.ports","title":"<code>ports</code>  <code>property</code>","text":"<p>Return the ports of this NIC.</p>"},{"location":"api/hardware_component/v_nic/#PyCloudSim.entity.v_nic.vNIC.__init__","title":"<code>__init__(host, label=None, create_at=None, terminate_at=None, precursor=None)</code>","text":"<p>Create a simulated NIC.</p> Source code in <code>PyCloudSim\\entity\\v_nic.py</code> <pre><code>def __init__(\n    self,\n    host: vHardwareEntity | vGateway,\n    label: str | None = None,\n    create_at: int\n    | float\n    | Callable[..., int]\n    | Callable[..., float]\n    | None = None,\n    terminate_at: int\n    | float\n    | Callable[..., int]\n    | Callable[..., float]\n    | None = None,\n    precursor: Entity | List[Entity] | None = None,\n) -&gt; None:\n    \"\"\"Create a simulated NIC.\"\"\"\n    super().__init__(label, create_at, terminate_at, precursor)\n    self._host = host\n    self._ports: List[vPort] = EntityList(label=f\"{self} Ports\")\n    self._packet_queue: List[vPacket] = EntityList(label=f\"{self} Packet Queue\")\n</code></pre>"},{"location":"api/hardware_component/v_nic/#PyCloudSim.entity.v_nic.vNIC.add_port","title":"<code>add_port(endpoint, bandwidth, ip_address, at)</code>","text":"<p>Add a port to this virtual NIC.</p> Source code in <code>PyCloudSim\\entity\\v_nic.py</code> <pre><code>def add_port(\n    self,\n    endpoint: vHardwareEntity | vGateway,\n    bandwidth: int | Callable[..., int],\n    ip_address: IPv4Address | None,\n    at: int | float,\n):\n    \"\"\"Add a port to this virtual NIC.\"\"\"\n\n    @self.instant_event(at, label=f\"{self} Add Port to {endpoint}\")\n    def _add_port():\n        port = vPort(\n            self,\n            endpoint,\n            bandwidth,\n            ip_address=ip_address,\n            label=f\"{self.label}-{len(self.ports)}\",\n            create_at=simulation.now,\n        )\n        self.ports.append(port)\n</code></pre>"},{"location":"api/hardware_component/v_nic/#PyCloudSim.entity.v_nic.vNIC.egress_usage","title":"<code>egress_usage(duration=None)</code>","text":"<p>Return the egress bandwidth usage of this NIC.</p> Source code in <code>PyCloudSim\\entity\\v_nic.py</code> <pre><code>def egress_usage(self, duration: int | float | None = None):\n    \"\"\"Return the egress bandwidth usage of this NIC.\"\"\"\n    return sum([port.usage(duration) for port in self.ports])\n</code></pre>"},{"location":"api/hardware_component/v_nic/#PyCloudSim.entity.v_nic.vNIC.egress_utilization","title":"<code>egress_utilization(duration=None)</code>","text":"<p>Return the egress bandwidth utilization of this NIC.</p> Source code in <code>PyCloudSim\\entity\\v_nic.py</code> <pre><code>def egress_utilization(self, duration: int | float | None = None):\n    \"\"\"Return the egress bandwidth utilization of this NIC.\"\"\"\n    return sum([port.utilization(duration) for port in self.ports]) / len(\n        self.ports\n    )\n</code></pre>"},{"location":"api/hardware_component/v_nic/#PyCloudSim.entity.v_nic.vNIC.ingress_usage","title":"<code>ingress_usage(duration=None)</code>","text":"<p>Return the ingress bandwidth usage of this NIC.</p> Source code in <code>PyCloudSim\\entity\\v_nic.py</code> <pre><code>def ingress_usage(self, duration: int | float | None = None):\n    \"\"\"Return the ingress bandwidth usage of this NIC.\"\"\"\n    connected_nodes = [\n        port.endpoint for port in self.ports\n    ]\n    ingress_usage = 0\n    for node in connected_nodes:\n        for port in node.NIC.ports:\n            if port.endpoint is self.host:\n                ingress_usage += port.usage(duration)\n    return ingress_usage\n</code></pre>"},{"location":"api/hardware_component/v_nic/#PyCloudSim.entity.v_nic.vNIC.ingress_utilization","title":"<code>ingress_utilization(duration=None)</code>","text":"<p>Return the ingress bandwidth utilization of this NIC.</p> Source code in <code>PyCloudSim\\entity\\v_nic.py</code> <pre><code>def ingress_utilization(self, duration: int | float | None = None):\n    \"\"\"Return the ingress bandwidth utilization of this NIC.\"\"\"\n    connected_nodes = [\n        port.endpoint for port in self.ports\n    ]\n    ingress_utilization = 0\n    for node in connected_nodes:\n        for port in node.NIC.ports:\n            if port.endpoint is self.host:\n                ingress_utilization += port.utilization(duration)\n    return ingress_utilization / len(connected_nodes)\n</code></pre>"},{"location":"api/hardware_component/v_nic/#PyCloudSim.entity.v_nic.vNIC.on_power_off","title":"<code>on_power_off()</code>","text":"<p>Power off the simulated NIC.</p> Source code in <code>PyCloudSim\\entity\\v_nic.py</code> <pre><code>def on_power_off(self) -&gt; None:\n    \"\"\"Power off the simulated NIC.\"\"\"\n    super().on_power_off()\n    for event in self.events:\n        if event.label == f\"{self} Transmit Packets\":\n            event.cancel()\n</code></pre>"},{"location":"api/hardware_component/v_nic/#PyCloudSim.entity.v_nic.vNIC.on_power_on","title":"<code>on_power_on()</code>","text":"<p>Power on the simulated NIC.</p> Source code in <code>PyCloudSim\\entity\\v_nic.py</code> <pre><code>def on_power_on(self) -&gt; None:\n    \"\"\"Power on the simulated NIC.\"\"\"\n    super().on_power_on()\n    for port in self.ports:\n        port.power_on(simulation.now)\n\n    @self.continuous_event(\n        at=simulation.now,\n        interval=simulation.min_time_unit,\n        duration=inf,\n        label=f\"{self} Transmit Packets\",\n    )\n    def _schedule_packets():\n        \"\"\"A continous event to schedule packets in the queue.\"\"\"\n        self.packet_queue.sort(key=lambda packet: packet.priority)\n        for packet in self.packet_queue:\n            # check if packet is decoded\n            if packet.decoded and not packet.in_transmission:\n                logger.debug(f\"{simulation.now}:\\t{self} is scheduling {packet}.\")\n                # find the port to transmit the packet to the next hop\n                try:\n                    src_port = [\n                        port\n                        for port in self.ports\n                        if port.endpoint is packet.next_hop\n                    ][0]\n                except:\n                    raise RuntimeError(\n                        f\"Can not find a port on {packet.path[0]} to transmit {packet}.\"\n                    )\n                # find the port to receive the packet on the next hop\n                try:\n                    dst_port = [\n                        port\n                        for port in packet.next_hop.NIC.ports\n                        if port.endpoint is packet.current_hop\n                    ][0]\n                except:\n                    raise RuntimeError(\n                        f\"Can not find a port on {packet.path[1]} to receive {packet}.\"\n                    )\n                logger.debug(\n                    f\"{simulation.now}:\\t{self} found src port {src_port} and dst port {dst_port} for {packet}\"\n                )\n                # calculate the available bandwidth and transmission time\n                available_bandwidth = min(\n                    src_port.bandwidth.amount, dst_port.bandwidth.amount\n                )\n                logger.debug(\n                    f\"{simulation.now}:\\t{self} found available bandwidth {available_bandwidth} for {packet}\"\n                )\n                # check if the packet can be transmitted\n                if available_bandwidth &gt; packet.size:\n                    packet.state.append(Constants.INTRANSMISSION)\n                    link_speed = min(\n                        src_port.bandwidth.capacity, dst_port.bandwidth.capacity\n                    )\n                    # calculate the transmission time\n                    transmission_time = packet.size / link_speed\n\n                    # packet consumes the bandwidth of the src port and returns the bandwidth in future\n                    src_port.transmit(packet, transmission_time)\n\n                    # packet consumes the bandwidth of the dst port and returns the bandwidth in future\n                    dst_port.receive(packet, transmission_time)\n\n                    logger.info(\n                        f\"{simulation.now}:\\t{packet} in transmission from {src_port.host} to {dst_port.host}\"\n                    )\n            else:\n                # pass packets that have not been decoded\n                pass\n</code></pre>"},{"location":"api/hardware_component/v_nic/#PyCloudSim.entity.v_nic.vNIC.remove_port","title":"<code>remove_port(endpoint, at)</code>","text":"<p>Remove a port from this virtual NIC.</p> Source code in <code>PyCloudSim\\entity\\v_nic.py</code> <pre><code>def remove_port(self, endpoint: vHardwareEntity, at: int | float):\n    \"\"\"Remove a port from this virtual NIC.\"\"\"\n\n    @self.instant_event(at, label=f\"{self} Remove Port to {endpoint}\")\n    def _remove_port():\n        for port in self.ports:\n            if port.endpoint is endpoint:\n                port.terminate(simulation.now)\n</code></pre>"},{"location":"api/hardware_entity/","title":"Index","text":"<p>The <code>PhysicalEntity</code> class is the base for all simulated physical entities such as Host, Switch and Router.</p> <p>             Bases: <code>Entity</code></p> Source code in <code>PyCloudSim\\entity\\v_hardware_entity.py</code> <pre><code>class vHardwareEntity(Entity):\n    def __init__(\n        self,\n        ipc: int | Callable,\n        frequency: int | Callable,\n        num_cores: int | Callable,\n        cpu_tdps: int | float | Callable,\n        cpu_mode: int,\n        ram: int | Callable,\n        rom: int | Callable,\n        architecture: str = Constants.X86,\n        label: str | None = None,\n        create_at: int\n        | float\n        | Callable[..., int]\n        | Callable[..., float]\n        | None = None,\n        terminate_at: int\n        | float\n        | Callable[..., int]\n        | Callable[..., float]\n        | None = None,\n        precursor: Entity | List[Entity] | None = None,\n    ) -&gt; None:\n        \"\"\"Create a simulated hardware entity.\n\n        Args:\n            ipc (int | Callable): the instructions per cycle (IPC) of the CPU.\n            frequency (int | Callable): the frequency of the CPU, in MHz.\n            num_cores (int | Callable): the number of cores of the CPU.\n            cpu_tdps (int | float | Callable): the thermal design power (TDP) of the CPU, in Watts.\n            ram (int | Callable): the RAM of the hardware entity, in GiB.\n            rom (int | Callable): the ROM of the hardware entity, in GiB.\n            label (str | None, optional): the short name for the entity. Defaults to None.\n            create_at (int | float | Callable[..., Any] | None, optional): when the enity should be created. Defaults to None.\n            terminate_at (int | float | Callable[..., Any] | None, optional): when the entity should be terminated. Defaults to None.\n            precursor (Entity | List[Entity] | None, optional): the presursors that must be terminated before the creation of this entity. Defaults to None.\n        \"\"\"\n        super().__init__(label, create_at, terminate_at, precursor)\n\n        self._cpu = vCPU(\n            ipc, frequency, num_cores, cpu_tdps, cpu_mode, self, label=f\"{label}\"\n        )\n        if callable(ram):\n            self._ram = Resource(\n                capacity=GiB(round(ram())).bytes, label=f\"{self.label}-RAM\"\n            )\n        else:\n            self._ram = Resource(capacity=GiB(ram).bytes, label=f\"{self.label}-RAM\")\n        if callable(rom):\n            self._rom = Resource(\n                capacity=GiB(round(rom())).bytes, label=f\"{self.label}-ROM\"\n            )\n        else:\n            self._rom = Resource(capacity=GiB(rom).bytes, label=f\"{self.label}-ROM\")\n\n        if architecture in [Constants.X86, Constants.ARM]:\n            self._architecture = architecture\n        else:\n            raise ValueError(f\"Platform {architecture} is not supported.\")\n        self._NIC = vNIC(host=self, label=f\"{self}-NIC\")\n\n    def on_creation(self):\n        simulation.network.add_node(self)\n        self.cpu.create(simulation.now)\n        self.NIC.create(simulation.now)\n        self.NIC.add_port(\n            endpoint=self,\n            bandwidth=10000,\n            at=simulation.now,\n            ip_address=IPv4Address(\"127.0.0.1\"),\n        )\n\n    def on_termination(self):\n        simulation.network.del_node(self)\n        self.cpu.terminate(simulation.now)\n        self.NIC.terminate(simulation.now)\n\n    def power_on(self, at: int | float) -&gt; None:\n        \"\"\"Power on the hardware entity\"\"\"\n\n        if self.powered_on:\n            warnings.warn(f\"{self.label} is already powered on.\")\n            return\n\n        if self.failed:\n            warnings.warn(f\"{self.label} is failed.\")\n            return\n\n        if self.terminated:\n            warnings.warn(f\"{self.label} is terminated.\")\n            return\n\n        for event in self.events:\n            if event.label == f\"{self.label} Power On\":\n                if at &gt; event.at:\n                    return\n\n        @self.instant_event(at, label=f\"{self.label} Power On\", priority=-1)\n        def _power_on() -&gt; None:\n            if self.powered_on or self.failed or self.terminated:\n                return\n            self.cpu.power_on(simulation.now)\n            self.NIC.power_on(simulation.now)\n            self.on_power_on()\n            self.state.append(Constants.POWER_ON)\n            if Constants.POWER_OFF in self.state:\n                self.state.remove(Constants.POWER_OFF)\n\n    def on_power_on(self) -&gt; None:\n        \"\"\"Called when the hardware entity is powered on\"\"\"\n        simulation.network.add_node(self)\n\n    def power_off(self, at: int | float) -&gt; None:\n        \"\"\"Power off the hardware entity\"\"\"\n\n        if self.powered_off:\n            warnings.warn(f\"{self.label} is already powered off.\")\n            return\n        if self.failed:\n            warnings.warn(f\"{self.label} is failed.\")\n            return\n\n        if self.terminated:\n            warnings.warn(f\"{self.label} is terminated.\")\n            return\n\n        for event in self.events:\n            if event.label == f\"{self.label} Power Off\":\n                if at &gt; event.at:\n                    return\n\n        @self.instant_event(at, label=f\"{self.label} Power Off\", priority=-1)\n        def _power_off() -&gt; None:\n            if self.powered_off or self.failed or self.terminated:\n                return\n            self.cpu.power_off(simulation.now)\n            self.NIC.power_off(simulation.now)\n            self.on_power_off()\n            self.state.append(Constants.POWER_OFF)\n            if Constants.POWER_ON in self.state:\n                self.state.remove(Constants.POWER_ON)\n\n    def on_power_off(self) -&gt; None:\n        \"\"\"Called when the hardware entity is powered off\"\"\"\n        simulation.network.del_node(self)\n\n    def fail(self, at: int | float) -&gt; None:\n        \"\"\"Fail the hardware entity\"\"\"\n\n        if self.failed:\n            warnings.warn(f\"{self.label} is already failed.\")\n            return\n\n        if self.terminated:\n            warnings.warn(f\"{self.label} is terminated.\")\n            return\n\n        for event in self.events:\n            if event.label == f\"{self.label} Fail\":\n                if at &gt; event.at:\n                    return\n\n        @self.instant_event(at, label=f\"{self.label} Fail\")\n        def _fail() -&gt; None:\n            if self.failed or self.terminated:\n                return\n            self.cpu.fail(simulation.now)\n            self.NIC.fail(simulation.now)\n            self.on_fail()\n            self.power_off(simulation.now)\n            self.state.append(Constants.FAIL)\n\n    def on_fail(self) -&gt; None:\n        \"\"\"Called when the hardware entity fails\"\"\"\n        pass\n\n    def receive_packet(self, packet: vPacket) -&gt; None:\n        \"\"\"Receive a packet from the NIC. A decoding virtual process will be created if the packet is successfully received. The decoding process simulates the processing delay.\"\"\"\n        if packet.decoded:\n            packet.state.remove(Constants.DECODED)\n\n        if packet.in_transmission:\n            packet.state.remove(Constants.INTRANSMISSION)\n\n        try:\n            packet.get(self.ram, packet.size)\n        except:\n            packet.drop()\n            return\n        self.packet_queue.append(packet)\n        packet._current_hop = self\n        if packet.current_hop is not packet.dst_host:\n            packet._next_hop = packet.path[indexOf(packet.path, self) + 1]\n        decoder = vDecoder(\n            packet=packet,\n            length=packet.size,\n            host=self,\n            label=f\"{packet} Decoder\",\n            create_at=simulation.now,\n        )\n        logger.info(f\"{simulation.now}:\\t{self} receives {packet}.\")\n\n    def drop_packet(self, packet: vPacket) -&gt; None:\n        \"\"\"Drop a packet from the NIC. It should not be called manually.\"\"\"\n        packet.drop()\n\n    def __str__(self) -&gt; str:\n        return f\"{self.__class__.__name__}-{self.label}\"\n\n    @property\n    def powered_on(self) -&gt; bool:\n        \"\"\"Return True if the hardware entity is powered on\"\"\"\n        return Constants.POWER_ON in self.state\n\n    @property\n    def powered_off(self) -&gt; bool:\n        \"\"\"Return True if the hardware entity is powered off\"\"\"\n        return Constants.POWER_OFF in self.state or Constants.POWER_ON not in self.state\n\n    @property\n    def failed(self) -&gt; bool:\n        \"\"\"Return True if the hardware component fails\"\"\"\n        return Constants.FAIL in self.state\n\n    @property\n    def cpu(self) -&gt; vCPU:\n        \"\"\"Return the CPU of the hardware entity\"\"\"\n        return self._cpu\n\n    @property\n    def ram(self) -&gt; Resource:\n        \"\"\"Return the RAM of the hardware entity\"\"\"\n        return self._ram\n\n    @property\n    def rom(self) -&gt; Resource:\n        \"\"\"Return the ROM of the hardware entity\"\"\"\n        return self._rom\n\n    @property\n    def NIC(self) -&gt; vNIC:\n        \"\"\"Return the NIC of the hardware entity\"\"\"\n        return self._NIC\n\n    @property\n    def packet_queue(self):\n        \"\"\"Return the packet queue of the hardware entity\"\"\"\n        return self.NIC.packet_queue\n\n    @property\n    def process_queue(self):\n        \"\"\"Return the process queue of the hardware entity\"\"\"\n        return self.cpu.process_queue\n\n    @property\n    def architecture(self):\n        \"\"\"Return the architecture of the hardware entity\"\"\"\n        return self._architecture\n\n    def cpu_usage(self, duration: int | float | None = None) -&gt; float:\n        \"\"\"Return the CPU usage of the hardware entity\"\"\"\n        return self.cpu.usage(duration=duration)\n\n    def cpu_utilization(self, duration: int | float | None = None) -&gt; float:\n        \"\"\"Return the CPU utilization of the hardware entity\"\"\"\n        return self.cpu.utilization(duration=duration)\n\n    def ram_usage(self, duration: int | float | None = None) -&gt; float:\n        \"\"\"Return the RAM usage of the hardware entity\"\"\"\n        return self.ram.usage(duration=duration)\n\n    def ram_utilization(self, duration: int | float | None = None) -&gt; float:\n        \"\"\"Return the RAM utilization of the hardware entity\"\"\"\n        return self.ram.utilization(duration=duration)\n</code></pre>"},{"location":"api/hardware_entity/#PyCloudSim.entity.v_hardware_entity.vHardwareEntity.NIC","title":"<code>NIC: vNIC</code>  <code>property</code>","text":"<p>Return the NIC of the hardware entity</p>"},{"location":"api/hardware_entity/#PyCloudSim.entity.v_hardware_entity.vHardwareEntity.architecture","title":"<code>architecture</code>  <code>property</code>","text":"<p>Return the architecture of the hardware entity</p>"},{"location":"api/hardware_entity/#PyCloudSim.entity.v_hardware_entity.vHardwareEntity.cpu","title":"<code>cpu: vCPU</code>  <code>property</code>","text":"<p>Return the CPU of the hardware entity</p>"},{"location":"api/hardware_entity/#PyCloudSim.entity.v_hardware_entity.vHardwareEntity.failed","title":"<code>failed: bool</code>  <code>property</code>","text":"<p>Return True if the hardware component fails</p>"},{"location":"api/hardware_entity/#PyCloudSim.entity.v_hardware_entity.vHardwareEntity.packet_queue","title":"<code>packet_queue</code>  <code>property</code>","text":"<p>Return the packet queue of the hardware entity</p>"},{"location":"api/hardware_entity/#PyCloudSim.entity.v_hardware_entity.vHardwareEntity.powered_off","title":"<code>powered_off: bool</code>  <code>property</code>","text":"<p>Return True if the hardware entity is powered off</p>"},{"location":"api/hardware_entity/#PyCloudSim.entity.v_hardware_entity.vHardwareEntity.powered_on","title":"<code>powered_on: bool</code>  <code>property</code>","text":"<p>Return True if the hardware entity is powered on</p>"},{"location":"api/hardware_entity/#PyCloudSim.entity.v_hardware_entity.vHardwareEntity.process_queue","title":"<code>process_queue</code>  <code>property</code>","text":"<p>Return the process queue of the hardware entity</p>"},{"location":"api/hardware_entity/#PyCloudSim.entity.v_hardware_entity.vHardwareEntity.ram","title":"<code>ram: Resource</code>  <code>property</code>","text":"<p>Return the RAM of the hardware entity</p>"},{"location":"api/hardware_entity/#PyCloudSim.entity.v_hardware_entity.vHardwareEntity.rom","title":"<code>rom: Resource</code>  <code>property</code>","text":"<p>Return the ROM of the hardware entity</p>"},{"location":"api/hardware_entity/#PyCloudSim.entity.v_hardware_entity.vHardwareEntity.__init__","title":"<code>__init__(ipc, frequency, num_cores, cpu_tdps, cpu_mode, ram, rom, architecture=Constants.X86, label=None, create_at=None, terminate_at=None, precursor=None)</code>","text":"<p>Create a simulated hardware entity.</p> <p>Parameters:</p> Name Type Description Default <code>ipc</code> <code>int | Callable</code> <p>the instructions per cycle (IPC) of the CPU.</p> required <code>frequency</code> <code>int | Callable</code> <p>the frequency of the CPU, in MHz.</p> required <code>num_cores</code> <code>int | Callable</code> <p>the number of cores of the CPU.</p> required <code>cpu_tdps</code> <code>int | float | Callable</code> <p>the thermal design power (TDP) of the CPU, in Watts.</p> required <code>ram</code> <code>int | Callable</code> <p>the RAM of the hardware entity, in GiB.</p> required <code>rom</code> <code>int | Callable</code> <p>the ROM of the hardware entity, in GiB.</p> required <code>label</code> <code>str | None</code> <p>the short name for the entity. Defaults to None.</p> <code>None</code> <code>create_at</code> <code>int | float | Callable[..., Any] | None</code> <p>when the enity should be created. Defaults to None.</p> <code>None</code> <code>terminate_at</code> <code>int | float | Callable[..., Any] | None</code> <p>when the entity should be terminated. Defaults to None.</p> <code>None</code> <code>precursor</code> <code>Entity | List[Entity] | None</code> <p>the presursors that must be terminated before the creation of this entity. Defaults to None.</p> <code>None</code> Source code in <code>PyCloudSim\\entity\\v_hardware_entity.py</code> <pre><code>def __init__(\n    self,\n    ipc: int | Callable,\n    frequency: int | Callable,\n    num_cores: int | Callable,\n    cpu_tdps: int | float | Callable,\n    cpu_mode: int,\n    ram: int | Callable,\n    rom: int | Callable,\n    architecture: str = Constants.X86,\n    label: str | None = None,\n    create_at: int\n    | float\n    | Callable[..., int]\n    | Callable[..., float]\n    | None = None,\n    terminate_at: int\n    | float\n    | Callable[..., int]\n    | Callable[..., float]\n    | None = None,\n    precursor: Entity | List[Entity] | None = None,\n) -&gt; None:\n    \"\"\"Create a simulated hardware entity.\n\n    Args:\n        ipc (int | Callable): the instructions per cycle (IPC) of the CPU.\n        frequency (int | Callable): the frequency of the CPU, in MHz.\n        num_cores (int | Callable): the number of cores of the CPU.\n        cpu_tdps (int | float | Callable): the thermal design power (TDP) of the CPU, in Watts.\n        ram (int | Callable): the RAM of the hardware entity, in GiB.\n        rom (int | Callable): the ROM of the hardware entity, in GiB.\n        label (str | None, optional): the short name for the entity. Defaults to None.\n        create_at (int | float | Callable[..., Any] | None, optional): when the enity should be created. Defaults to None.\n        terminate_at (int | float | Callable[..., Any] | None, optional): when the entity should be terminated. Defaults to None.\n        precursor (Entity | List[Entity] | None, optional): the presursors that must be terminated before the creation of this entity. Defaults to None.\n    \"\"\"\n    super().__init__(label, create_at, terminate_at, precursor)\n\n    self._cpu = vCPU(\n        ipc, frequency, num_cores, cpu_tdps, cpu_mode, self, label=f\"{label}\"\n    )\n    if callable(ram):\n        self._ram = Resource(\n            capacity=GiB(round(ram())).bytes, label=f\"{self.label}-RAM\"\n        )\n    else:\n        self._ram = Resource(capacity=GiB(ram).bytes, label=f\"{self.label}-RAM\")\n    if callable(rom):\n        self._rom = Resource(\n            capacity=GiB(round(rom())).bytes, label=f\"{self.label}-ROM\"\n        )\n    else:\n        self._rom = Resource(capacity=GiB(rom).bytes, label=f\"{self.label}-ROM\")\n\n    if architecture in [Constants.X86, Constants.ARM]:\n        self._architecture = architecture\n    else:\n        raise ValueError(f\"Platform {architecture} is not supported.\")\n    self._NIC = vNIC(host=self, label=f\"{self}-NIC\")\n</code></pre>"},{"location":"api/hardware_entity/#PyCloudSim.entity.v_hardware_entity.vHardwareEntity.cpu_usage","title":"<code>cpu_usage(duration=None)</code>","text":"<p>Return the CPU usage of the hardware entity</p> Source code in <code>PyCloudSim\\entity\\v_hardware_entity.py</code> <pre><code>def cpu_usage(self, duration: int | float | None = None) -&gt; float:\n    \"\"\"Return the CPU usage of the hardware entity\"\"\"\n    return self.cpu.usage(duration=duration)\n</code></pre>"},{"location":"api/hardware_entity/#PyCloudSim.entity.v_hardware_entity.vHardwareEntity.cpu_utilization","title":"<code>cpu_utilization(duration=None)</code>","text":"<p>Return the CPU utilization of the hardware entity</p> Source code in <code>PyCloudSim\\entity\\v_hardware_entity.py</code> <pre><code>def cpu_utilization(self, duration: int | float | None = None) -&gt; float:\n    \"\"\"Return the CPU utilization of the hardware entity\"\"\"\n    return self.cpu.utilization(duration=duration)\n</code></pre>"},{"location":"api/hardware_entity/#PyCloudSim.entity.v_hardware_entity.vHardwareEntity.drop_packet","title":"<code>drop_packet(packet)</code>","text":"<p>Drop a packet from the NIC. It should not be called manually.</p> Source code in <code>PyCloudSim\\entity\\v_hardware_entity.py</code> <pre><code>def drop_packet(self, packet: vPacket) -&gt; None:\n    \"\"\"Drop a packet from the NIC. It should not be called manually.\"\"\"\n    packet.drop()\n</code></pre>"},{"location":"api/hardware_entity/#PyCloudSim.entity.v_hardware_entity.vHardwareEntity.fail","title":"<code>fail(at)</code>","text":"<p>Fail the hardware entity</p> Source code in <code>PyCloudSim\\entity\\v_hardware_entity.py</code> <pre><code>def fail(self, at: int | float) -&gt; None:\n    \"\"\"Fail the hardware entity\"\"\"\n\n    if self.failed:\n        warnings.warn(f\"{self.label} is already failed.\")\n        return\n\n    if self.terminated:\n        warnings.warn(f\"{self.label} is terminated.\")\n        return\n\n    for event in self.events:\n        if event.label == f\"{self.label} Fail\":\n            if at &gt; event.at:\n                return\n\n    @self.instant_event(at, label=f\"{self.label} Fail\")\n    def _fail() -&gt; None:\n        if self.failed or self.terminated:\n            return\n        self.cpu.fail(simulation.now)\n        self.NIC.fail(simulation.now)\n        self.on_fail()\n        self.power_off(simulation.now)\n        self.state.append(Constants.FAIL)\n</code></pre>"},{"location":"api/hardware_entity/#PyCloudSim.entity.v_hardware_entity.vHardwareEntity.on_fail","title":"<code>on_fail()</code>","text":"<p>Called when the hardware entity fails</p> Source code in <code>PyCloudSim\\entity\\v_hardware_entity.py</code> <pre><code>def on_fail(self) -&gt; None:\n    \"\"\"Called when the hardware entity fails\"\"\"\n    pass\n</code></pre>"},{"location":"api/hardware_entity/#PyCloudSim.entity.v_hardware_entity.vHardwareEntity.on_power_off","title":"<code>on_power_off()</code>","text":"<p>Called when the hardware entity is powered off</p> Source code in <code>PyCloudSim\\entity\\v_hardware_entity.py</code> <pre><code>def on_power_off(self) -&gt; None:\n    \"\"\"Called when the hardware entity is powered off\"\"\"\n    simulation.network.del_node(self)\n</code></pre>"},{"location":"api/hardware_entity/#PyCloudSim.entity.v_hardware_entity.vHardwareEntity.on_power_on","title":"<code>on_power_on()</code>","text":"<p>Called when the hardware entity is powered on</p> Source code in <code>PyCloudSim\\entity\\v_hardware_entity.py</code> <pre><code>def on_power_on(self) -&gt; None:\n    \"\"\"Called when the hardware entity is powered on\"\"\"\n    simulation.network.add_node(self)\n</code></pre>"},{"location":"api/hardware_entity/#PyCloudSim.entity.v_hardware_entity.vHardwareEntity.power_off","title":"<code>power_off(at)</code>","text":"<p>Power off the hardware entity</p> Source code in <code>PyCloudSim\\entity\\v_hardware_entity.py</code> <pre><code>def power_off(self, at: int | float) -&gt; None:\n    \"\"\"Power off the hardware entity\"\"\"\n\n    if self.powered_off:\n        warnings.warn(f\"{self.label} is already powered off.\")\n        return\n    if self.failed:\n        warnings.warn(f\"{self.label} is failed.\")\n        return\n\n    if self.terminated:\n        warnings.warn(f\"{self.label} is terminated.\")\n        return\n\n    for event in self.events:\n        if event.label == f\"{self.label} Power Off\":\n            if at &gt; event.at:\n                return\n\n    @self.instant_event(at, label=f\"{self.label} Power Off\", priority=-1)\n    def _power_off() -&gt; None:\n        if self.powered_off or self.failed or self.terminated:\n            return\n        self.cpu.power_off(simulation.now)\n        self.NIC.power_off(simulation.now)\n        self.on_power_off()\n        self.state.append(Constants.POWER_OFF)\n        if Constants.POWER_ON in self.state:\n            self.state.remove(Constants.POWER_ON)\n</code></pre>"},{"location":"api/hardware_entity/#PyCloudSim.entity.v_hardware_entity.vHardwareEntity.power_on","title":"<code>power_on(at)</code>","text":"<p>Power on the hardware entity</p> Source code in <code>PyCloudSim\\entity\\v_hardware_entity.py</code> <pre><code>def power_on(self, at: int | float) -&gt; None:\n    \"\"\"Power on the hardware entity\"\"\"\n\n    if self.powered_on:\n        warnings.warn(f\"{self.label} is already powered on.\")\n        return\n\n    if self.failed:\n        warnings.warn(f\"{self.label} is failed.\")\n        return\n\n    if self.terminated:\n        warnings.warn(f\"{self.label} is terminated.\")\n        return\n\n    for event in self.events:\n        if event.label == f\"{self.label} Power On\":\n            if at &gt; event.at:\n                return\n\n    @self.instant_event(at, label=f\"{self.label} Power On\", priority=-1)\n    def _power_on() -&gt; None:\n        if self.powered_on or self.failed or self.terminated:\n            return\n        self.cpu.power_on(simulation.now)\n        self.NIC.power_on(simulation.now)\n        self.on_power_on()\n        self.state.append(Constants.POWER_ON)\n        if Constants.POWER_OFF in self.state:\n            self.state.remove(Constants.POWER_OFF)\n</code></pre>"},{"location":"api/hardware_entity/#PyCloudSim.entity.v_hardware_entity.vHardwareEntity.ram_usage","title":"<code>ram_usage(duration=None)</code>","text":"<p>Return the RAM usage of the hardware entity</p> Source code in <code>PyCloudSim\\entity\\v_hardware_entity.py</code> <pre><code>def ram_usage(self, duration: int | float | None = None) -&gt; float:\n    \"\"\"Return the RAM usage of the hardware entity\"\"\"\n    return self.ram.usage(duration=duration)\n</code></pre>"},{"location":"api/hardware_entity/#PyCloudSim.entity.v_hardware_entity.vHardwareEntity.ram_utilization","title":"<code>ram_utilization(duration=None)</code>","text":"<p>Return the RAM utilization of the hardware entity</p> Source code in <code>PyCloudSim\\entity\\v_hardware_entity.py</code> <pre><code>def ram_utilization(self, duration: int | float | None = None) -&gt; float:\n    \"\"\"Return the RAM utilization of the hardware entity\"\"\"\n    return self.ram.utilization(duration=duration)\n</code></pre>"},{"location":"api/hardware_entity/#PyCloudSim.entity.v_hardware_entity.vHardwareEntity.receive_packet","title":"<code>receive_packet(packet)</code>","text":"<p>Receive a packet from the NIC. A decoding virtual process will be created if the packet is successfully received. The decoding process simulates the processing delay.</p> Source code in <code>PyCloudSim\\entity\\v_hardware_entity.py</code> <pre><code>def receive_packet(self, packet: vPacket) -&gt; None:\n    \"\"\"Receive a packet from the NIC. A decoding virtual process will be created if the packet is successfully received. The decoding process simulates the processing delay.\"\"\"\n    if packet.decoded:\n        packet.state.remove(Constants.DECODED)\n\n    if packet.in_transmission:\n        packet.state.remove(Constants.INTRANSMISSION)\n\n    try:\n        packet.get(self.ram, packet.size)\n    except:\n        packet.drop()\n        return\n    self.packet_queue.append(packet)\n    packet._current_hop = self\n    if packet.current_hop is not packet.dst_host:\n        packet._next_hop = packet.path[indexOf(packet.path, self) + 1]\n    decoder = vDecoder(\n        packet=packet,\n        length=packet.size,\n        host=self,\n        label=f\"{packet} Decoder\",\n        create_at=simulation.now,\n    )\n    logger.info(f\"{simulation.now}:\\t{self} receives {packet}.\")\n</code></pre>"},{"location":"api/hardware_entity/v_gateway/","title":"vGateway","text":"<p>The class \"vGateway\" is a unique implementation of the \"PhysicalEntity\" class. Unlike other entities, the \"vGateway\" does not possess a \"vCPU\", RAM, or ROM. Its primary role is to function as the entry point for the cloud environment, serving as the central hub for incoming and outgoing user traffic.</p> <p>The \"vGateway\" inherits all the member functions implemented for the \"vSwitch\" class, allowing it to perform routing and switching operations. However, unlike other entities, the \"vGateway\" does not create a simulated process for packet decoding upon receiving simulated packets.</p> <p>Additionally, the \"vGateway\" is designed to be linked exclusively with \"vRouter\" instances, facilitating seamless connectivity and routing between the gateway and the routers within the simulated network topology.</p> <p>             Bases: <code>Entity</code></p> Source code in <code>PyCloudSim\\entity\\v_gateway.py</code> <pre><code>class vGateway(Entity):\n    def __init__(\n        self,\n        label: str | None = None,\n    ) -&gt; None:\n        \"\"\"Create a virtual gateway.\n\n        Args:\n            label (str | None, optional): short description of the gateway. Defaults to None.\n        \"\"\"\n        super().__init__(label=label, create_at=0)\n\n        self._users: List[vUser] = EntityList()\n        self._NIC = vNIC(host=self, label=f\"{self}-NIC\")\n        self._ram = Resource(capacity=inf, label=f\"{self}-RAM\")\n        self._cpu = None\n\n    def on_creation(self):\n        simulation.topology.add_node(self)\n        self.NIC.create(simulation.now)\n        self.NIC.power_on(simulation.now)\n\n    def on_termination(self):\n        return super().on_termination()\n\n    def on_destruction(self):\n        return super().on_destruction()\n\n    def receive_packet(self, packet: vPacket) -&gt; None:\n        \"\"\"Receive a packet from the NIC.\"\"\"\n        if packet.decoded:\n            packet.state.remove(Constants.DECODED)\n        if packet.in_transmission:\n            packet.state.remove(Constants.INTRANSMISSION)\n        try:\n            packet.get(self.ram, packet.size)\n        except:\n            packet.drop()\n            return\n        self.packet_queue.append(packet)\n        packet._current_hop = self\n        if packet.current_hop is not packet.dst_host:\n            packet._next_hop = packet.path[indexOf(packet.path, self) + 1]\n        else:\n            packet.success(simulation.now)\n        logger.info(f\"{simulation.now}:\\t{self} receives {packet}.\")\n\n    @property\n    def users(self) -&gt; List[vUser]:\n        \"\"\"Returns the users asscociated with the gateway.\"\"\"\n        return self._users\n\n    @property\n    def NIC(self) -&gt; vNIC:\n        \"\"\"Return the NIC of this virtual gateway.\"\"\"\n        return self._NIC\n\n    @property\n    def ram(self) -&gt; Resource:\n        \"\"\"Return the RAM of the virtual gateway which has infinite capacity.\"\"\"\"\"\n        return self._ram\n\n    @property\n    def cpu(self):\n        \"\"\"Return the CPU of the virtual gateway which is none, created for avoid typing issues.\"\"\"\n        return self._cpu\n\n    @property\n    def packet_queue(self):\n        \"\"\"Return the packet queue of the hardware entity\"\"\"\n        return self.NIC.packet_queue\n</code></pre>"},{"location":"api/hardware_entity/v_gateway/#PyCloudSim.entity.v_gateway.vGateway.NIC","title":"<code>NIC: vNIC</code>  <code>property</code>","text":"<p>Return the NIC of this virtual gateway.</p>"},{"location":"api/hardware_entity/v_gateway/#PyCloudSim.entity.v_gateway.vGateway.cpu","title":"<code>cpu</code>  <code>property</code>","text":"<p>Return the CPU of the virtual gateway which is none, created for avoid typing issues.</p>"},{"location":"api/hardware_entity/v_gateway/#PyCloudSim.entity.v_gateway.vGateway.packet_queue","title":"<code>packet_queue</code>  <code>property</code>","text":"<p>Return the packet queue of the hardware entity</p>"},{"location":"api/hardware_entity/v_gateway/#PyCloudSim.entity.v_gateway.vGateway.ram","title":"<code>ram: Resource</code>  <code>property</code>","text":"<p>Return the RAM of the virtual gateway which has infinite capacity.</p>"},{"location":"api/hardware_entity/v_gateway/#PyCloudSim.entity.v_gateway.vGateway.users","title":"<code>users: List[vUser]</code>  <code>property</code>","text":"<p>Returns the users asscociated with the gateway.</p>"},{"location":"api/hardware_entity/v_gateway/#PyCloudSim.entity.v_gateway.vGateway.__init__","title":"<code>__init__(label=None)</code>","text":"<p>Create a virtual gateway.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str | None</code> <p>short description of the gateway. Defaults to None.</p> <code>None</code> Source code in <code>PyCloudSim\\entity\\v_gateway.py</code> <pre><code>def __init__(\n    self,\n    label: str | None = None,\n) -&gt; None:\n    \"\"\"Create a virtual gateway.\n\n    Args:\n        label (str | None, optional): short description of the gateway. Defaults to None.\n    \"\"\"\n    super().__init__(label=label, create_at=0)\n\n    self._users: List[vUser] = EntityList()\n    self._NIC = vNIC(host=self, label=f\"{self}-NIC\")\n    self._ram = Resource(capacity=inf, label=f\"{self}-RAM\")\n    self._cpu = None\n</code></pre>"},{"location":"api/hardware_entity/v_gateway/#PyCloudSim.entity.v_gateway.vGateway.receive_packet","title":"<code>receive_packet(packet)</code>","text":"<p>Receive a packet from the NIC.</p> Source code in <code>PyCloudSim\\entity\\v_gateway.py</code> <pre><code>def receive_packet(self, packet: vPacket) -&gt; None:\n    \"\"\"Receive a packet from the NIC.\"\"\"\n    if packet.decoded:\n        packet.state.remove(Constants.DECODED)\n    if packet.in_transmission:\n        packet.state.remove(Constants.INTRANSMISSION)\n    try:\n        packet.get(self.ram, packet.size)\n    except:\n        packet.drop()\n        return\n    self.packet_queue.append(packet)\n    packet._current_hop = self\n    if packet.current_hop is not packet.dst_host:\n        packet._next_hop = packet.path[indexOf(packet.path, self) + 1]\n    else:\n        packet.success(simulation.now)\n    logger.info(f\"{simulation.now}:\\t{self} receives {packet}.\")\n</code></pre>"},{"location":"api/hardware_entity/v_host/","title":"vHost","text":"<p>The <code>vHost</code> class is the implementation of simulated Host.</p> <p>             Bases: <code>vHardwareEntity</code></p> Source code in <code>PyCloudSim\\entity\\v_host.py</code> <pre><code>class vHost(vHardwareEntity):\n    def __init__(\n        self,\n        ipc: int | Callable[..., Any],\n        frequency: int | Callable[..., Any],\n        num_cores: int | Callable[..., Any],\n        cpu_tdps: int | float | Callable[..., Any],\n        cpu_mode: int,\n        ram: int | Callable[..., Any],\n        rom: int | Callable[..., Any],\n        architecture: str = Constants.X86,\n        label: str | None = None,\n        create_at: int\n        | float\n        | Callable[..., int]\n        | Callable[..., float]\n        | None = None,\n        terminate_at: int\n        | float\n        | Callable[..., int]\n        | Callable[..., float]\n        | None = None,\n        precursor: Entity | List[Entity] | None = None,\n    ) -&gt; None:\n        \"\"\"Create a simulated host.\n\n        Args:\n            ipc (int | Callable[..., Any]): the instructions per cycle (IPC) of the CPU.\n            frequency (int | Callable[..., Any]): the frequency of the CPU.\n            num_cores (int | Callable[..., Any]): the number of cores of the CPU.\n            cpu_tdps (int | float | Callable[..., Any]): the thermal design power (TDP) of the CPU.\n            ram (int | Callable[..., Any]): the RAM capacity of the host, in GiB.\n            rom (int | Callable[..., Any]): the ROm capacity of the host, in GiB.\n            label (str | None, optional): the short name of the host. Defaults to None.\n            create_at (int | float | Callable[..., Any] | None, optional): when this host should be created. Defaults to None.\n            terminate_at (int | float | Callable[..., Any] | None, optional): when this host should be terminated. Defaults to None.\n            precursor (Entity | List[Entity] | None, optional): the precursors that must be terminated before this host is created. Defaults to None.\n        \"\"\"\n        super().__init__(\n            ipc,\n            frequency,\n            num_cores,\n            cpu_tdps,\n            cpu_mode,\n            ram,\n            rom,\n            architecture,\n            label,\n            create_at,\n            terminate_at,\n            precursor,\n        )\n\n        if callable(ram):\n            self._ram_reservoir = Resource(\n                capacity=GiB(round(ram())).bytes, label=f\"{self} RAM Reservoir\"\n            )\n        else:\n            self._ram_reservoir = Resource(\n                capacity=GiB(ram).bytes, label=f\"{self} RAM Reservoir\"\n            )\n\n        if callable(rom):\n            self._rom_reservoir = Resource(\n                capacity=GiB(round(rom())).bytes, label=f\"{self} ROM Reservoir\"\n            )\n        else:\n            self._rom_reservoir = Resource(\n                capacity=GiB(rom).bytes, label=f\"{self} ROM Reservoir\"\n            )\n\n        self._container_queue: List[vContainer] = EntityList(\n            label=f\"{self} Container Queue\"\n        )\n        self._volume_queue: List[vVolume] = EntityList(label=f\"{self} Volume Queue\")\n\n    def on_power_off(self) -&gt; None:\n        for container in self.container_queue:\n            container.terminate(at=simulation.now)\n\n    def allocate_container(self, container: vContainer) -&gt; None:\n        \"\"\"Allocate a container to the host. This will start the creation of the container.\"\"\"\n        self._container_queue.append(container)\n        container.get(self.cpu_reservoir, container.cpu)\n        container.get(self.ram_reservoir, container.ram)\n        container.get(self.rom_reservoir, container.image_size)\n        container._host = self\n        container.state.append(Constants.SCHEDULED)\n        container.initiate(simulation.now)\n        logger.info(\n            f\"{simulation.now}:\\t{container} is allocated to {self}, available CPU {self.cpu_reservoir.utilization():.2f}% | RAM {self.ram_reservoir.utilization():.2f}% | ROM {self.rom_reservoir.utilization():.2f}%.\"\n        )\n\n    def allocate_volume(self, volume: vVolume) -&gt; None:\n        self._volume_queue.append(volume)\n        volume.get(self.rom_reservoir, volume.size)\n        volume._host = self\n        volume.state.append(Constants.SCHEDULED)\n        logger.info(\n            f\"{simulation.now}:\\t{volume} is allocated to {self}, available ROM {self.rom_reservoir.utilization():.2f}%.\"\n        )\n\n    @property\n    def cpu_reservoir(self):\n        \"\"\"Return the CPU reservoir, used in container allocation.\"\"\"\n        return self.cpu.computational_power_reservoir\n\n    @property\n    def ram_reservoir(self):\n        \"\"\"Return the RAM reservoir, used in container allocation.\"\"\"\n        return self._ram_reservoir\n\n    @property\n    def rom_reservoir(self):\n        \"\"\"Return the ROM reservoir, used in container allocation.\"\"\"\n        return self._rom_reservoir\n\n    @property\n    def container_queue(self):\n        \"\"\"Return the container queue, all the containers allocated on the host.\"\"\"\n        return self._container_queue\n\n    @property\n    def volume_queue(self):\n        \"\"\"Return the volume queue, all the volumes allocated on the host.\"\"\"\n        return self._volume_queue\n\n    @property\n    def ip_address(self):\n        \"\"\"Return the IP address of the host.\"\"\"\n        return [port.ip_address for port in self.NIC.ports]\n</code></pre>"},{"location":"api/hardware_entity/v_host/#PyCloudSim.entity.v_host.vHost.container_queue","title":"<code>container_queue</code>  <code>property</code>","text":"<p>Return the container queue, all the containers allocated on the host.</p>"},{"location":"api/hardware_entity/v_host/#PyCloudSim.entity.v_host.vHost.cpu_reservoir","title":"<code>cpu_reservoir</code>  <code>property</code>","text":"<p>Return the CPU reservoir, used in container allocation.</p>"},{"location":"api/hardware_entity/v_host/#PyCloudSim.entity.v_host.vHost.ip_address","title":"<code>ip_address</code>  <code>property</code>","text":"<p>Return the IP address of the host.</p>"},{"location":"api/hardware_entity/v_host/#PyCloudSim.entity.v_host.vHost.ram_reservoir","title":"<code>ram_reservoir</code>  <code>property</code>","text":"<p>Return the RAM reservoir, used in container allocation.</p>"},{"location":"api/hardware_entity/v_host/#PyCloudSim.entity.v_host.vHost.rom_reservoir","title":"<code>rom_reservoir</code>  <code>property</code>","text":"<p>Return the ROM reservoir, used in container allocation.</p>"},{"location":"api/hardware_entity/v_host/#PyCloudSim.entity.v_host.vHost.volume_queue","title":"<code>volume_queue</code>  <code>property</code>","text":"<p>Return the volume queue, all the volumes allocated on the host.</p>"},{"location":"api/hardware_entity/v_host/#PyCloudSim.entity.v_host.vHost.__init__","title":"<code>__init__(ipc, frequency, num_cores, cpu_tdps, cpu_mode, ram, rom, architecture=Constants.X86, label=None, create_at=None, terminate_at=None, precursor=None)</code>","text":"<p>Create a simulated host.</p> <p>Parameters:</p> Name Type Description Default <code>ipc</code> <code>int | Callable[..., Any]</code> <p>the instructions per cycle (IPC) of the CPU.</p> required <code>frequency</code> <code>int | Callable[..., Any]</code> <p>the frequency of the CPU.</p> required <code>num_cores</code> <code>int | Callable[..., Any]</code> <p>the number of cores of the CPU.</p> required <code>cpu_tdps</code> <code>int | float | Callable[..., Any]</code> <p>the thermal design power (TDP) of the CPU.</p> required <code>ram</code> <code>int | Callable[..., Any]</code> <p>the RAM capacity of the host, in GiB.</p> required <code>rom</code> <code>int | Callable[..., Any]</code> <p>the ROm capacity of the host, in GiB.</p> required <code>label</code> <code>str | None</code> <p>the short name of the host. Defaults to None.</p> <code>None</code> <code>create_at</code> <code>int | float | Callable[..., Any] | None</code> <p>when this host should be created. Defaults to None.</p> <code>None</code> <code>terminate_at</code> <code>int | float | Callable[..., Any] | None</code> <p>when this host should be terminated. Defaults to None.</p> <code>None</code> <code>precursor</code> <code>Entity | List[Entity] | None</code> <p>the precursors that must be terminated before this host is created. Defaults to None.</p> <code>None</code> Source code in <code>PyCloudSim\\entity\\v_host.py</code> <pre><code>def __init__(\n    self,\n    ipc: int | Callable[..., Any],\n    frequency: int | Callable[..., Any],\n    num_cores: int | Callable[..., Any],\n    cpu_tdps: int | float | Callable[..., Any],\n    cpu_mode: int,\n    ram: int | Callable[..., Any],\n    rom: int | Callable[..., Any],\n    architecture: str = Constants.X86,\n    label: str | None = None,\n    create_at: int\n    | float\n    | Callable[..., int]\n    | Callable[..., float]\n    | None = None,\n    terminate_at: int\n    | float\n    | Callable[..., int]\n    | Callable[..., float]\n    | None = None,\n    precursor: Entity | List[Entity] | None = None,\n) -&gt; None:\n    \"\"\"Create a simulated host.\n\n    Args:\n        ipc (int | Callable[..., Any]): the instructions per cycle (IPC) of the CPU.\n        frequency (int | Callable[..., Any]): the frequency of the CPU.\n        num_cores (int | Callable[..., Any]): the number of cores of the CPU.\n        cpu_tdps (int | float | Callable[..., Any]): the thermal design power (TDP) of the CPU.\n        ram (int | Callable[..., Any]): the RAM capacity of the host, in GiB.\n        rom (int | Callable[..., Any]): the ROm capacity of the host, in GiB.\n        label (str | None, optional): the short name of the host. Defaults to None.\n        create_at (int | float | Callable[..., Any] | None, optional): when this host should be created. Defaults to None.\n        terminate_at (int | float | Callable[..., Any] | None, optional): when this host should be terminated. Defaults to None.\n        precursor (Entity | List[Entity] | None, optional): the precursors that must be terminated before this host is created. Defaults to None.\n    \"\"\"\n    super().__init__(\n        ipc,\n        frequency,\n        num_cores,\n        cpu_tdps,\n        cpu_mode,\n        ram,\n        rom,\n        architecture,\n        label,\n        create_at,\n        terminate_at,\n        precursor,\n    )\n\n    if callable(ram):\n        self._ram_reservoir = Resource(\n            capacity=GiB(round(ram())).bytes, label=f\"{self} RAM Reservoir\"\n        )\n    else:\n        self._ram_reservoir = Resource(\n            capacity=GiB(ram).bytes, label=f\"{self} RAM Reservoir\"\n        )\n\n    if callable(rom):\n        self._rom_reservoir = Resource(\n            capacity=GiB(round(rom())).bytes, label=f\"{self} ROM Reservoir\"\n        )\n    else:\n        self._rom_reservoir = Resource(\n            capacity=GiB(rom).bytes, label=f\"{self} ROM Reservoir\"\n        )\n\n    self._container_queue: List[vContainer] = EntityList(\n        label=f\"{self} Container Queue\"\n    )\n    self._volume_queue: List[vVolume] = EntityList(label=f\"{self} Volume Queue\")\n</code></pre>"},{"location":"api/hardware_entity/v_host/#PyCloudSim.entity.v_host.vHost.allocate_container","title":"<code>allocate_container(container)</code>","text":"<p>Allocate a container to the host. This will start the creation of the container.</p> Source code in <code>PyCloudSim\\entity\\v_host.py</code> <pre><code>def allocate_container(self, container: vContainer) -&gt; None:\n    \"\"\"Allocate a container to the host. This will start the creation of the container.\"\"\"\n    self._container_queue.append(container)\n    container.get(self.cpu_reservoir, container.cpu)\n    container.get(self.ram_reservoir, container.ram)\n    container.get(self.rom_reservoir, container.image_size)\n    container._host = self\n    container.state.append(Constants.SCHEDULED)\n    container.initiate(simulation.now)\n    logger.info(\n        f\"{simulation.now}:\\t{container} is allocated to {self}, available CPU {self.cpu_reservoir.utilization():.2f}% | RAM {self.ram_reservoir.utilization():.2f}% | ROM {self.rom_reservoir.utilization():.2f}%.\"\n    )\n</code></pre>"},{"location":"api/hardware_entity/switch_router/","title":"Index","text":"<p>The class \"vSwitch\" and \"vRouter\" are the implementation of the switch and router in the simulated network topology. \"vSwitch\" and \"vRouter\" will create a scheduling process to schedule all \"vPacket\" in the queue to \"vNIC\" for transmission based on the priority of \"vPacket\" when a \"vPacket\" arrived or has been transmitted. The scheduling process is implemented as an \"event and only one scheduling process for each \"vSwitch\" or \"vRouter\" can exist at any time. If a \"vSwitch\" or \"vRouter\" does not have enough RAM to accommodate a \"vPacket\" upon receiving it, the \"vPacket\" will be dropped. The difference between \"vSwitch\" and \"vRouter\" are:</p> <ol> <li> <p>For a \"vSwitch,\" the IP address attribute of its \"vNIC\" is set to none, and its \"vNIC\" can be connected to any entity.</p> </li> <li> <p>For a \"vRouter,\" the IP address of each of its \"vNIC\" instances must belong to a unique network and its \"vNIC\" cannot be connected to a \"vHost\" entity.</p> </li> </ol>"},{"location":"api/hardware_entity/switch_router/v_router/","title":"vRouter","text":"<p>The class \"vSwitch\" and \"vRouter\" are the implementation of the switch and router in the simulated network topology. \"vSwitch\" and \"vRouter\" will create a scheduling process to schedule all \"vPacket\" in the queue to \"vNIC\" for transmission based on the priority of \"vPacket\" when a \"vPacket\" arrived or has been transmitted. The scheduling process is implemented as an \"event and only one scheduling process for each \"vSwitch\" or \"vRouter\" can exist at any time. If a \"vSwitch\" or \"vRouter\" does not have enough RAM to accommodate a \"vPacket\" upon receiving it, the \"vPacket\" will be dropped. The difference between \"vSwitch\" and \"vRouter\" are:</p> <ol> <li> <p>For a \"vSwitch,\" the IP address attribute of its \"vNIC\" is set to none, and its \"vNIC\" can be connected to any entity.</p> </li> <li> <p>For a \"vRouter,\" the IP address of each of its \"vNIC\" instances must belong to a unique network and its \"vNIC\" cannot be connected to a \"vHost\" entity.</p> </li> </ol> <p>             Bases: <code>vHardwareEntity</code></p> Source code in <code>PyCloudSim\\entity\\v_router.py</code> <pre><code>class vRouter(vHardwareEntity):\n    def __init__(\n        self,\n        ipc: int | Callable[..., Any],\n        frequency: int | Callable[..., Any],\n        num_cores: int | Callable[..., Any],\n        cpu_tdps: int | float | Callable[..., Any],\n        cpu_mode: int,\n        ram: int | Callable[..., Any],\n        rom: int | Callable[..., Any],\n        subnet: IPv4Network,\n        architecture: str = Constants.X86,\n        label: str | None = None,\n        create_at: int\n        | float\n        | Callable[..., int]\n        | Callable[..., float]\n        | None = None,\n        terminate_at: int\n        | float\n        | Callable[..., int]\n        | Callable[..., float]\n        | None = None,\n        precursor: Entity | List[Entity] | None = None,\n    ) -&gt; None:\n        super().__init__(\n            ipc,\n            frequency,\n            num_cores,\n            cpu_tdps,\n            cpu_mode,\n            ram,\n            rom,\n            architecture,\n            label,\n            create_at,\n            terminate_at,\n            precursor,\n        )\n</code></pre>"},{"location":"api/hardware_entity/switch_router/v_switch/","title":"vSwitch","text":"<p>The class \"vSwitch\" and \"vRouter\" are the implementation of the switch and router in the simulated network topology. \"vSwitch\" and \"vRouter\" will create a scheduling process to schedule all \"vPacket\" in the queue to \"vNIC\" for transmission based on the priority of \"vPacket\" when a \"vPacket\" arrived or has been transmitted. The scheduling process is implemented as an \"event and only one scheduling process for each \"vSwitch\" or \"vRouter\" can exist at any time. If a \"vSwitch\" or \"vRouter\" does not have enough RAM to accommodate a \"vPacket\" upon receiving it, the \"vPacket\" will be dropped. The difference between \"vSwitch\" and \"vRouter\" are:</p> <ol> <li> <p>For a \"vSwitch,\" the IP address attribute of its \"vNIC\" is set to none, and its \"vNIC\" can be connected to any entity.</p> </li> <li> <p>For a \"vRouter,\" the IP address of each of its \"vNIC\" instances must belong to a unique network and its \"vNIC\" cannot be connected to a \"vHost\" entity.</p> </li> </ol> <p>             Bases: <code>vHardwareEntity</code></p> Source code in <code>PyCloudSim\\entity\\v_switch.py</code> <pre><code>class vSwitch(vHardwareEntity):\n    def __init__(\n        self,\n        ipc: int | Callable[..., Any],\n        frequency: int | Callable[..., Any],\n        num_cores: int | Callable[..., Any],\n        cpu_tdps: int | float | Callable[..., Any],\n        cpu_mode: int,\n        ram: int | Callable[..., Any],\n        rom: int | Callable[..., Any],\n        subnet: IPv4Network,\n        architecture: str = Constants.X86,\n        label: str | None = None,\n        create_at: int\n        | float\n        | Callable[..., int]\n        | Callable[..., float]\n        | None = None,\n        terminate_at: int\n        | float\n        | Callable[..., int]\n        | Callable[..., float]\n        | None = None,\n        precursor: Entity | List[Entity] | None = None,\n    ) -&gt; None:\n        super().__init__(\n            ipc,\n            frequency,\n            num_cores,\n            cpu_tdps,\n            cpu_mode,\n            ram,\n            rom,\n            architecture,\n            label,\n            create_at,\n            terminate_at,\n            precursor,\n        )\n        self._subnet = subnet\n        self._available_ip_addresses = list(subnet.hosts())\n\n    @property\n    def subnet(self) -&gt; IPv4Network:\n        \"\"\"Returns the subnet of the vSwitch\"\"\"\n        return self._subnet\n\n    @property\n    def available_ip_addresses(self) -&gt; list[IPv4Address]:\n        \"\"\"Returns a list of available IP addresses in the subnet.\"\"\"\n        return self._available_ip_addresses\n</code></pre>"},{"location":"api/hardware_entity/switch_router/v_switch/#PyCloudSim.entity.v_switch.vSwitch.available_ip_addresses","title":"<code>available_ip_addresses: list[IPv4Address]</code>  <code>property</code>","text":"<p>Returns a list of available IP addresses in the subnet.</p>"},{"location":"api/hardware_entity/switch_router/v_switch/#PyCloudSim.entity.v_switch.vSwitch.subnet","title":"<code>subnet: IPv4Network</code>  <code>property</code>","text":"<p>Returns the subnet of the vSwitch</p>"},{"location":"api/monitor/container_monitor/","title":"Container Monitor","text":"<p>PyCloudSim has created a series of container monitor for convenience.</p>"},{"location":"api/monitor/container_monitor/#container-logging-monitor","title":"Container Logging Monitor","text":"<p>This monitor simply output the container telemetries in terminal</p> <p>             Bases: <code>Monitor</code></p> <p>A default container monitor that will simply log the CPU and RAM usage of the containers.</p> Source code in <code>PyCloudSim\\monitor\\container_monitor.py</code> <pre><code>class LoggingContainerMonitor(Monitor):\n    \"\"\"A default container monitor that will simply log the CPU and RAM usage of the containers.\n    \"\"\"\n    def __init__(\n        self,\n        label: str,\n        target_containers: List[vContainer] | None = None,\n        sample_period: int | float | Callable[..., int] | Callable[..., float] = 0.1,\n    ) -&gt; None:\n        \"\"\"Initialize the LoggingContainerMonitor.\n\n        Args:\n            label (str): short name of the monitor.\n            target_containers (List[vContainer] | None, optional): the container to be monitored. Defaults to None then all containers will be monitored.\n            sample_period (int | float | Callable[..., int] | Callable[..., float], optional): the sampling period. Defaults to 0.1.\n        \"\"\"\n        super().__init__(label, sample_period)\n\n        if target_containers is None:\n            self._target_containers = simulation.containers\n        else:\n            self._target_containers = target_containers\n\n    def on_observation(self, *arg, **kwargs):\n        \"\"\"Simply log the CPU and RAM usage of the containers.\n        \"\"\"\n        for container in self.target_containers:\n            if container.initiated:\n                logger.info(\n                    f\"{simulation.now}:\\t{container} CPU usage: {container.cpu_usage/container.cpu_limit*100:.2f}% , RAM usage: {container.ram_usage/container.ram_limit*100:.2f}%\"\n                )\n\n    @property\n    def target_containers(self):\n        \"\"\"Return the target containers of the monitor.\"\"\"\n        return self._target_containers\n</code></pre>"},{"location":"api/monitor/container_monitor/#PyCloudSim.monitor.container_monitor.LoggingContainerMonitor.target_containers","title":"<code>target_containers</code>  <code>property</code>","text":"<p>Return the target containers of the monitor.</p>"},{"location":"api/monitor/container_monitor/#PyCloudSim.monitor.container_monitor.LoggingContainerMonitor.__init__","title":"<code>__init__(label, target_containers=None, sample_period=0.1)</code>","text":"<p>Initialize the LoggingContainerMonitor.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>short name of the monitor.</p> required <code>target_containers</code> <code>List[vContainer] | None</code> <p>the container to be monitored. Defaults to None then all containers will be monitored.</p> <code>None</code> <code>sample_period</code> <code>int | float | Callable[..., int] | Callable[..., float]</code> <p>the sampling period. Defaults to 0.1.</p> <code>0.1</code> Source code in <code>PyCloudSim\\monitor\\container_monitor.py</code> <pre><code>def __init__(\n    self,\n    label: str,\n    target_containers: List[vContainer] | None = None,\n    sample_period: int | float | Callable[..., int] | Callable[..., float] = 0.1,\n) -&gt; None:\n    \"\"\"Initialize the LoggingContainerMonitor.\n\n    Args:\n        label (str): short name of the monitor.\n        target_containers (List[vContainer] | None, optional): the container to be monitored. Defaults to None then all containers will be monitored.\n        sample_period (int | float | Callable[..., int] | Callable[..., float], optional): the sampling period. Defaults to 0.1.\n    \"\"\"\n    super().__init__(label, sample_period)\n\n    if target_containers is None:\n        self._target_containers = simulation.containers\n    else:\n        self._target_containers = target_containers\n</code></pre>"},{"location":"api/monitor/container_monitor/#PyCloudSim.monitor.container_monitor.LoggingContainerMonitor.on_observation","title":"<code>on_observation(*arg, **kwargs)</code>","text":"<p>Simply log the CPU and RAM usage of the containers.</p> Source code in <code>PyCloudSim\\monitor\\container_monitor.py</code> <pre><code>def on_observation(self, *arg, **kwargs):\n    \"\"\"Simply log the CPU and RAM usage of the containers.\n    \"\"\"\n    for container in self.target_containers:\n        if container.initiated:\n            logger.info(\n                f\"{simulation.now}:\\t{container} CPU usage: {container.cpu_usage/container.cpu_limit*100:.2f}% , RAM usage: {container.ram_usage/container.ram_limit*100:.2f}%\"\n            )\n</code></pre>"},{"location":"api/monitor/container_monitor/#container-dataframe-monitor","title":"Container Dataframe Monitor","text":"<p>This monitor create a pandas data frame to record the container telemetries.</p> <p>             Bases: <code>Monitor</code></p> <p>A simple monitor that will log the CPU and RAM usage of the containers in a dataframe.</p> Source code in <code>PyCloudSim\\monitor\\container_monitor.py</code> <pre><code>class DataframeContainerMonitor(Monitor):\n    \"\"\"A simple monitor that will log the CPU and RAM usage of the containers in a dataframe.\"\"\"\n    def __init__(\n        self,\n        label: str,\n        target_containers: List[vContainer] | None = None,\n        sample_period: int | float | Callable[..., int] | Callable[..., float] = 0.1,\n    ) -&gt; None:\n        \"\"\"Initialize the LoggingContainerMonitor.\n\n        Args:\n            label (str): short name of the monitor.\n            target_containers (List[vContainer] | None, optional): the container to be monitored. Defaults to None then all containers will be monitored.\n            sample_period (int | float | Callable[..., int] | Callable[..., float], optional): the sampling period. Defaults to 0.1.\n        \"\"\"\n        super().__init__(label, sample_period)\n\n        if target_containers is None:\n            self._target_containers = simulation.containers\n        else:\n            self._target_containers = target_containers\n\n        self._dataframe = pd.DataFrame({\n            \"time\": pd.Series([], dtype=\"str\"),\n            \"container_label\": pd.Series([], dtype=\"str\"),\n            \"cpu_usage\": pd.Series([], dtype=\"float\"),\n            \"cpu_usage_percent\": pd.Series([], dtype=\"float\"),\n            \"ram_usage\": pd.Series([], dtype=\"float\"),\n            \"ram_usage_percent\": pd.Series([], dtype=\"float\"),\n            \"num_of_process\": pd.Series([], dtype=\"int\"),\n        })\n\n    def on_observation(self, *arg, **kwargs):\n        \"\"\"Collect the data from the containers and append it to the dataframe.\"\"\"\n        for container in self.target_containers:\n            if container.initiated:\n                container_telemetries = pd.DataFrame(\n                    {\n                        \"time\": pd.Series([simulation.now], dtype=\"str\"),\n                        \"container_label\": pd.Series([container.label], dtype=\"str\"),\n                        \"cpu_usage\": pd.Series([container.cpu_usage], dtype=\"float\"),\n                        \"cpu_usage_percent\": pd.Series([container.cpu_usage/container.cpu_limit*100], dtype=\"float\"),\n                        \"ram_usage\": pd.Series([container.ram_usage], dtype=\"float\"),\n                        \"ram_usage_percent\": pd.Series([container.ram_usage/container.ram_limit*100], dtype=\"float\"),\n                        \"num_of_process\": pd.Series([len(container.process_queue)], dtype=\"int\"),\n                    }\n                )\n                self._dataframe = pd.concat([self._dataframe, container_telemetries], ignore_index=True)\n\n\n    @property\n    def target_containers(self):\n        \"\"\"Return the target containers of the monitor.\"\"\"\n        return self._target_containers\n\n    @property\n    def dataframe(self):\n        \"\"\"Return the dataframe of the monitor.\"\"\"\n        return self._dataframe\n</code></pre>"},{"location":"api/monitor/container_monitor/#PyCloudSim.monitor.container_monitor.DataframeContainerMonitor.dataframe","title":"<code>dataframe</code>  <code>property</code>","text":"<p>Return the dataframe of the monitor.</p>"},{"location":"api/monitor/container_monitor/#PyCloudSim.monitor.container_monitor.DataframeContainerMonitor.target_containers","title":"<code>target_containers</code>  <code>property</code>","text":"<p>Return the target containers of the monitor.</p>"},{"location":"api/monitor/container_monitor/#PyCloudSim.monitor.container_monitor.DataframeContainerMonitor.__init__","title":"<code>__init__(label, target_containers=None, sample_period=0.1)</code>","text":"<p>Initialize the LoggingContainerMonitor.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>short name of the monitor.</p> required <code>target_containers</code> <code>List[vContainer] | None</code> <p>the container to be monitored. Defaults to None then all containers will be monitored.</p> <code>None</code> <code>sample_period</code> <code>int | float | Callable[..., int] | Callable[..., float]</code> <p>the sampling period. Defaults to 0.1.</p> <code>0.1</code> Source code in <code>PyCloudSim\\monitor\\container_monitor.py</code> <pre><code>def __init__(\n    self,\n    label: str,\n    target_containers: List[vContainer] | None = None,\n    sample_period: int | float | Callable[..., int] | Callable[..., float] = 0.1,\n) -&gt; None:\n    \"\"\"Initialize the LoggingContainerMonitor.\n\n    Args:\n        label (str): short name of the monitor.\n        target_containers (List[vContainer] | None, optional): the container to be monitored. Defaults to None then all containers will be monitored.\n        sample_period (int | float | Callable[..., int] | Callable[..., float], optional): the sampling period. Defaults to 0.1.\n    \"\"\"\n    super().__init__(label, sample_period)\n\n    if target_containers is None:\n        self._target_containers = simulation.containers\n    else:\n        self._target_containers = target_containers\n\n    self._dataframe = pd.DataFrame({\n        \"time\": pd.Series([], dtype=\"str\"),\n        \"container_label\": pd.Series([], dtype=\"str\"),\n        \"cpu_usage\": pd.Series([], dtype=\"float\"),\n        \"cpu_usage_percent\": pd.Series([], dtype=\"float\"),\n        \"ram_usage\": pd.Series([], dtype=\"float\"),\n        \"ram_usage_percent\": pd.Series([], dtype=\"float\"),\n        \"num_of_process\": pd.Series([], dtype=\"int\"),\n    })\n</code></pre>"},{"location":"api/monitor/container_monitor/#PyCloudSim.monitor.container_monitor.DataframeContainerMonitor.on_observation","title":"<code>on_observation(*arg, **kwargs)</code>","text":"<p>Collect the data from the containers and append it to the dataframe.</p> Source code in <code>PyCloudSim\\monitor\\container_monitor.py</code> <pre><code>def on_observation(self, *arg, **kwargs):\n    \"\"\"Collect the data from the containers and append it to the dataframe.\"\"\"\n    for container in self.target_containers:\n        if container.initiated:\n            container_telemetries = pd.DataFrame(\n                {\n                    \"time\": pd.Series([simulation.now], dtype=\"str\"),\n                    \"container_label\": pd.Series([container.label], dtype=\"str\"),\n                    \"cpu_usage\": pd.Series([container.cpu_usage], dtype=\"float\"),\n                    \"cpu_usage_percent\": pd.Series([container.cpu_usage/container.cpu_limit*100], dtype=\"float\"),\n                    \"ram_usage\": pd.Series([container.ram_usage], dtype=\"float\"),\n                    \"ram_usage_percent\": pd.Series([container.ram_usage/container.ram_limit*100], dtype=\"float\"),\n                    \"num_of_process\": pd.Series([len(container.process_queue)], dtype=\"int\"),\n                }\n            )\n            self._dataframe = pd.concat([self._dataframe, container_telemetries], ignore_index=True)\n</code></pre>"},{"location":"api/monitor/host_monitor/","title":"Host Monitor","text":"<p>PyCloudSim has implemented a series of default host monitors for convenience.</p>"},{"location":"api/monitor/host_monitor/#host-logging-monitor","title":"Host Logging Monitor","text":"<p>This monitor simply output the telemetries of the host in terminal.</p> <p>             Bases: <code>Monitor</code></p> <p>A default host monitor that will simply log the CPU and RAM usage of the hosts.</p> Source code in <code>PyCloudSim\\monitor\\host_monitor.py</code> <pre><code>class LoggingHostMonitor(Monitor):\n    \"\"\"A default host monitor that will simply log the CPU and RAM usage of the hosts.\"\"\"\n\n    def __init__(\n        self,\n        label: str,\n        target_hosts: List[vHost] | None = None,\n        sample_period: int | float | Callable[..., int] | Callable[..., float] = 0.1,\n    ) -&gt; None:\n        \"\"\"Initialize the LoggingHostMonitor.\n\n        Args:\n            label (str): short name of the monitor.\n            target_hosts (List[vHost] | None, optional): the hosts to be monitored. Defaults to None then all hosts will be monitored.\n            sample_period (int | float | Callable[..., int] | Callable[..., float], optional): the sampling frequency. Defaults to 0.1.\n        \"\"\"\n        super().__init__(label, sample_period)\n\n        if target_hosts is None:\n            self._target_hosts = simulation.hosts\n        else:\n            self._target_hosts = target_hosts\n\n    def on_observation(self, *arg, **kwargs):\n        \"\"\"Collect the data from the hosts and log it.\"\"\"\n        for host in self.target_hosts:\n            if host.powered_on:\n                logger.info(\n                    f\"{simulation.now}:\\t{host} CPU usage: {host.cpu_utilization(self.sample_period)*100:.2f}% , RAM usage: {host.ram_utilization(self.sample_period)*100:.2f}%, BW-Out usage: {host.NIC.egress_usage(self.sample_period):.2f}%, BW-In usage: {host.NIC.ingress_usage(self.sample_period):.2f}%\"\n                )\n\n    @property\n    def target_hosts(self):\n        \"\"\"The target hosts of the monitor.\"\"\"\n        return self._target_hosts\n</code></pre>"},{"location":"api/monitor/host_monitor/#PyCloudSim.monitor.host_monitor.LoggingHostMonitor.target_hosts","title":"<code>target_hosts</code>  <code>property</code>","text":"<p>The target hosts of the monitor.</p>"},{"location":"api/monitor/host_monitor/#PyCloudSim.monitor.host_monitor.LoggingHostMonitor.__init__","title":"<code>__init__(label, target_hosts=None, sample_period=0.1)</code>","text":"<p>Initialize the LoggingHostMonitor.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>short name of the monitor.</p> required <code>target_hosts</code> <code>List[vHost] | None</code> <p>the hosts to be monitored. Defaults to None then all hosts will be monitored.</p> <code>None</code> <code>sample_period</code> <code>int | float | Callable[..., int] | Callable[..., float]</code> <p>the sampling frequency. Defaults to 0.1.</p> <code>0.1</code> Source code in <code>PyCloudSim\\monitor\\host_monitor.py</code> <pre><code>def __init__(\n    self,\n    label: str,\n    target_hosts: List[vHost] | None = None,\n    sample_period: int | float | Callable[..., int] | Callable[..., float] = 0.1,\n) -&gt; None:\n    \"\"\"Initialize the LoggingHostMonitor.\n\n    Args:\n        label (str): short name of the monitor.\n        target_hosts (List[vHost] | None, optional): the hosts to be monitored. Defaults to None then all hosts will be monitored.\n        sample_period (int | float | Callable[..., int] | Callable[..., float], optional): the sampling frequency. Defaults to 0.1.\n    \"\"\"\n    super().__init__(label, sample_period)\n\n    if target_hosts is None:\n        self._target_hosts = simulation.hosts\n    else:\n        self._target_hosts = target_hosts\n</code></pre>"},{"location":"api/monitor/host_monitor/#PyCloudSim.monitor.host_monitor.LoggingHostMonitor.on_observation","title":"<code>on_observation(*arg, **kwargs)</code>","text":"<p>Collect the data from the hosts and log it.</p> Source code in <code>PyCloudSim\\monitor\\host_monitor.py</code> <pre><code>def on_observation(self, *arg, **kwargs):\n    \"\"\"Collect the data from the hosts and log it.\"\"\"\n    for host in self.target_hosts:\n        if host.powered_on:\n            logger.info(\n                f\"{simulation.now}:\\t{host} CPU usage: {host.cpu_utilization(self.sample_period)*100:.2f}% , RAM usage: {host.ram_utilization(self.sample_period)*100:.2f}%, BW-Out usage: {host.NIC.egress_usage(self.sample_period):.2f}%, BW-In usage: {host.NIC.ingress_usage(self.sample_period):.2f}%\"\n            )\n</code></pre>"},{"location":"api/monitor/host_monitor/#host-dataframe-monitor","title":"Host Dataframe Monitor","text":"<p>This monitor will create a pandas dataframe to record the telemetries.</p> <p>             Bases: <code>Monitor</code></p> Source code in <code>PyCloudSim\\monitor\\host_monitor.py</code> <pre><code>class DataframeHostMonitor(Monitor):\n    def __init__(\n        self,\n        label: str,\n        target_hosts: List[vHost] | None = None,\n        sample_period: int | float | Callable[..., int] | Callable[..., float] = 0.1,\n    ) -&gt; None:\n        \"\"\"Initialize the LoggingHostMonitor.\n\n        Args:\n            label (str): short name of the monitor.\n            target_hosts (List[vHost] | None, optional): the hosts to be monitored. Defaults to None then all hosts will be monitored.\n            sample_period (int | float | Callable[..., int] | Callable[..., float], optional): the sampling frequency. Defaults to 0.1.\n        \"\"\"\n        super().__init__(label, sample_period)\n\n        if target_hosts is None:\n            self._target_hosts = simulation.hosts\n        else:\n            self._target_hosts = target_hosts\n\n        self._dataframe = pd.DataFrame(\n            {\n                \"time\": pd.Series([], dtype=\"str\"),\n                \"host_label\": pd.Series([], dtype=\"str\"),\n                \"cpu_usage\": pd.Series([], dtype=\"float\"),\n                \"cpu_usage_percent\": pd.Series([], dtype=\"float\"),\n                \"ram_usage\": pd.Series([], dtype=\"float\"),\n                \"ram_usage_percent\": pd.Series([], dtype=\"float\"),\n                \"rom_usage\": pd.Series([], dtype=\"float\"),\n                \"rom_usage_percent\": pd.Series([], dtype=\"float\"),\n                \"bandwidth_usage\": pd.Series([], dtype=\"float\"),\n                \"ingress_usage\": pd.Series([], dtype=\"float\"),\n                \"ingress_usage_percent\": pd.Series([], dtype=\"float\"),\n                \"egress_usage\": pd.Series([], dtype=\"float\"),\n                \"egress_usage_percent\": pd.Series([], dtype=\"float\"),\n            }\n        )\n\n    def on_observation(self, *arg, **kwargs):\n        \"\"\"Collect the data from the hosts and append it to the dataframe.\"\"\"\n        for host in self.target_hosts:\n            host_telemetries = pd.DataFrame(\n                {\n                    \"time\": pd.Series([simulation.now], dtype=\"str\"),\n                    \"host_label\": pd.Series([host.label], dtype=\"str\"),\n                    \"cpu_usage\": pd.Series(\n                        [host.cpu_usage(self.sample_period)], dtype=\"float\"\n                    ),\n                    \"cpu_usage_percent\": pd.Series(\n                        [host.cpu_utilization(self.sample_period) * 100], dtype=\"float\"\n                    ),\n                    \"ram_usage\": pd.Series(\n                        [host.ram_usage(self.sample_period)], dtype=\"float\"\n                    ),\n                    \"ram_usage_percent\": pd.Series(\n                        [host.ram_utilization(self.sample_period) * 100], dtype=\"float\"\n                    ),\n                    \"rom_usage\": pd.Series(\n                        [host.rom.usage(self.sample_period)], dtype=\"float\"\n                    ),\n                    \"rom_usage_percent\": pd.Series(\n                        [host.rom.utilization(self.sample_period) * 100], dtype=\"float\"\n                    ),\n                    \"bandwidth_usage\": pd.Series(\n                        [host.NIC.egress_usage(self.sample_period)], dtype=\"float\"\n                    ),\n                    \"ingress_usage\": pd.Series(\n                        [host.NIC.ingress_usage(self.sample_period)], dtype=\"float\"\n                    ),\n                    \"ingress_usage_percent\": pd.Series(\n                        [host.NIC.ingress_utilization(self.sample_period) * 100],\n                        dtype=\"float\",\n                    ),\n                    \"egress_usage\": pd.Series(\n                        [host.NIC.egress_usage(self.sample_period)], dtype=\"float\"\n                    ),\n                    \"egress_usage_percent\": pd.Series(\n                        [host.NIC.egress_utilization(self.sample_period) * 100],\n                        dtype=\"float\",\n                    ),\n                }\n            )\n            self._dataframe = pd.concat(\n                [self._dataframe, host_telemetries], ignore_index=True\n            )\n\n    @property\n    def target_hosts(self):\n        \"\"\"The target hosts of the monitor.\"\"\"\n        return self._target_hosts\n\n    @property\n    def dataframe(self):\n        \"\"\"Return the dataframe of the monitor.\"\"\"\n        return self._dataframe\n</code></pre>"},{"location":"api/monitor/host_monitor/#PyCloudSim.monitor.host_monitor.DataframeHostMonitor.dataframe","title":"<code>dataframe</code>  <code>property</code>","text":"<p>Return the dataframe of the monitor.</p>"},{"location":"api/monitor/host_monitor/#PyCloudSim.monitor.host_monitor.DataframeHostMonitor.target_hosts","title":"<code>target_hosts</code>  <code>property</code>","text":"<p>The target hosts of the monitor.</p>"},{"location":"api/monitor/host_monitor/#PyCloudSim.monitor.host_monitor.DataframeHostMonitor.__init__","title":"<code>__init__(label, target_hosts=None, sample_period=0.1)</code>","text":"<p>Initialize the LoggingHostMonitor.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>short name of the monitor.</p> required <code>target_hosts</code> <code>List[vHost] | None</code> <p>the hosts to be monitored. Defaults to None then all hosts will be monitored.</p> <code>None</code> <code>sample_period</code> <code>int | float | Callable[..., int] | Callable[..., float]</code> <p>the sampling frequency. Defaults to 0.1.</p> <code>0.1</code> Source code in <code>PyCloudSim\\monitor\\host_monitor.py</code> <pre><code>def __init__(\n    self,\n    label: str,\n    target_hosts: List[vHost] | None = None,\n    sample_period: int | float | Callable[..., int] | Callable[..., float] = 0.1,\n) -&gt; None:\n    \"\"\"Initialize the LoggingHostMonitor.\n\n    Args:\n        label (str): short name of the monitor.\n        target_hosts (List[vHost] | None, optional): the hosts to be monitored. Defaults to None then all hosts will be monitored.\n        sample_period (int | float | Callable[..., int] | Callable[..., float], optional): the sampling frequency. Defaults to 0.1.\n    \"\"\"\n    super().__init__(label, sample_period)\n\n    if target_hosts is None:\n        self._target_hosts = simulation.hosts\n    else:\n        self._target_hosts = target_hosts\n\n    self._dataframe = pd.DataFrame(\n        {\n            \"time\": pd.Series([], dtype=\"str\"),\n            \"host_label\": pd.Series([], dtype=\"str\"),\n            \"cpu_usage\": pd.Series([], dtype=\"float\"),\n            \"cpu_usage_percent\": pd.Series([], dtype=\"float\"),\n            \"ram_usage\": pd.Series([], dtype=\"float\"),\n            \"ram_usage_percent\": pd.Series([], dtype=\"float\"),\n            \"rom_usage\": pd.Series([], dtype=\"float\"),\n            \"rom_usage_percent\": pd.Series([], dtype=\"float\"),\n            \"bandwidth_usage\": pd.Series([], dtype=\"float\"),\n            \"ingress_usage\": pd.Series([], dtype=\"float\"),\n            \"ingress_usage_percent\": pd.Series([], dtype=\"float\"),\n            \"egress_usage\": pd.Series([], dtype=\"float\"),\n            \"egress_usage_percent\": pd.Series([], dtype=\"float\"),\n        }\n    )\n</code></pre>"},{"location":"api/monitor/host_monitor/#PyCloudSim.monitor.host_monitor.DataframeHostMonitor.on_observation","title":"<code>on_observation(*arg, **kwargs)</code>","text":"<p>Collect the data from the hosts and append it to the dataframe.</p> Source code in <code>PyCloudSim\\monitor\\host_monitor.py</code> <pre><code>def on_observation(self, *arg, **kwargs):\n    \"\"\"Collect the data from the hosts and append it to the dataframe.\"\"\"\n    for host in self.target_hosts:\n        host_telemetries = pd.DataFrame(\n            {\n                \"time\": pd.Series([simulation.now], dtype=\"str\"),\n                \"host_label\": pd.Series([host.label], dtype=\"str\"),\n                \"cpu_usage\": pd.Series(\n                    [host.cpu_usage(self.sample_period)], dtype=\"float\"\n                ),\n                \"cpu_usage_percent\": pd.Series(\n                    [host.cpu_utilization(self.sample_period) * 100], dtype=\"float\"\n                ),\n                \"ram_usage\": pd.Series(\n                    [host.ram_usage(self.sample_period)], dtype=\"float\"\n                ),\n                \"ram_usage_percent\": pd.Series(\n                    [host.ram_utilization(self.sample_period) * 100], dtype=\"float\"\n                ),\n                \"rom_usage\": pd.Series(\n                    [host.rom.usage(self.sample_period)], dtype=\"float\"\n                ),\n                \"rom_usage_percent\": pd.Series(\n                    [host.rom.utilization(self.sample_period) * 100], dtype=\"float\"\n                ),\n                \"bandwidth_usage\": pd.Series(\n                    [host.NIC.egress_usage(self.sample_period)], dtype=\"float\"\n                ),\n                \"ingress_usage\": pd.Series(\n                    [host.NIC.ingress_usage(self.sample_period)], dtype=\"float\"\n                ),\n                \"ingress_usage_percent\": pd.Series(\n                    [host.NIC.ingress_utilization(self.sample_period) * 100],\n                    dtype=\"float\",\n                ),\n                \"egress_usage\": pd.Series(\n                    [host.NIC.egress_usage(self.sample_period)], dtype=\"float\"\n                ),\n                \"egress_usage_percent\": pd.Series(\n                    [host.NIC.egress_utilization(self.sample_period) * 100],\n                    dtype=\"float\",\n                ),\n            }\n        )\n        self._dataframe = pd.concat(\n            [self._dataframe, host_telemetries], ignore_index=True\n        )\n</code></pre>"},{"location":"api/monitor/monitor/","title":"Monitor","text":"<p>             Bases: <code>Entity</code>, <code>ABC</code></p> Source code in <code>PyCloudSim\\monitor\\__init__.py</code> <pre><code>class Monitor(Entity, ABC):\n    def __init__(\n        self,\n        label: str,\n        sample_period: int | float | Callable[..., int] | Callable[..., float] = 0.1,\n    ) -&gt; None:\n        \"\"\"Base class for all monitors\n\n        Args:\n            label (str): the short name of the monitor.\n            sample_period (int | float | Callable[..., int] | Callable[..., float], optional): the sample period. Defaults to 0.1.\n        \"\"\"\n        super().__init__(label=label, create_at=0)\n\n        if callable(sample_period):\n            self._sample_period = sample_period()\n        else:\n            self._sample_period = sample_period\n\n    def on_creation(self):\n        @self.continuous_event(\n            at=simulation.now,\n            interval=self._sample_period,\n            duration=inf,\n            label=f\"{self.label} Observer\",\n        )\n        def _observe():\n            self.on_observation()\n\n    def on_termination(self):\n        return super().on_termination()\n\n    def on_destruction(self):\n        return super().on_destruction()\n\n    @abstractmethod\n    def on_observation(self, *arg, **kwargs):\n        \"\"\"The method to be called at each observation/sample.\"\"\"\n        pass\n\n    @property\n    def sample_period(self):\n        \"\"\"Return the sample period of the monitor.\"\"\"\n        return self._sample_period\n</code></pre>"},{"location":"api/monitor/monitor/#PyCloudSim.monitor.Monitor.sample_period","title":"<code>sample_period</code>  <code>property</code>","text":"<p>Return the sample period of the monitor.</p>"},{"location":"api/monitor/monitor/#PyCloudSim.monitor.Monitor.__init__","title":"<code>__init__(label, sample_period=0.1)</code>","text":"<p>Base class for all monitors</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>the short name of the monitor.</p> required <code>sample_period</code> <code>int | float | Callable[..., int] | Callable[..., float]</code> <p>the sample period. Defaults to 0.1.</p> <code>0.1</code> Source code in <code>PyCloudSim\\monitor\\__init__.py</code> <pre><code>def __init__(\n    self,\n    label: str,\n    sample_period: int | float | Callable[..., int] | Callable[..., float] = 0.1,\n) -&gt; None:\n    \"\"\"Base class for all monitors\n\n    Args:\n        label (str): the short name of the monitor.\n        sample_period (int | float | Callable[..., int] | Callable[..., float], optional): the sample period. Defaults to 0.1.\n    \"\"\"\n    super().__init__(label=label, create_at=0)\n\n    if callable(sample_period):\n        self._sample_period = sample_period()\n    else:\n        self._sample_period = sample_period\n</code></pre>"},{"location":"api/monitor/monitor/#PyCloudSim.monitor.Monitor.on_observation","title":"<code>on_observation(*arg, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>The method to be called at each observation/sample.</p> Source code in <code>PyCloudSim\\monitor\\__init__.py</code> <pre><code>@abstractmethod\ndef on_observation(self, *arg, **kwargs):\n    \"\"\"The method to be called at each observation/sample.\"\"\"\n    pass\n</code></pre>"},{"location":"api/scheduler/container_scheduler/","title":"Container Scheduler","text":"<p>The \"ContainerScheduler\" class is responsible for allocating suitable \"vHost\" instances to \"vContainer\" instances based on the available CPU and RAM resources. The scheduling process is implemented as an event that is triggered whenever a new \"vContainer\" is created or a \"vContainer\" is terminated. Only one scheduling process can exist at any time during the simulation.</p> <p>The \"ContainerScheduler\" class includes an abstract member function called \"findHost\", which allows developers to customize the conditions for determining which \"vHost\" instances are eligible for hosting a specific \"vContainer\". By implementing the \"findHost\" function, different scheduling strategies can be employed based on specific requirements and constraints.</p> <p>PyCloudSim provides several default schedulers that can be used with the \"ContainerScheduler\" class:</p> <ol> <li>\"Bestfit\" scheduler: This scheduler finds the most utilized \"vHost\" instance that still has available resources to host the \"vContainer\" being scheduled.</li> <li>\"Worstfit\" scheduler: This scheduler finds the most underutilized \"vHost\" instance that still has available resources to host the \"vContainer\" being scheduled.</li> <li>\"Random\" scheduler: This scheduler allocates the \"vContainer\" to a random \"vHost\" instance that has sufficient resources.</li> </ol> <p>Only one \"ContainerScheduler\" can be defined and used in the simulation. If multiple \"ContainerScheduler\" instances are initialized, the last one defined will be used during the simulation.</p> <p>The general procedure followed by the \"ContainerScheduler\" involves evaluating the available resources of each \"vHost\" instance and selecting the most suitable \"vHost\" to host the \"vContainer\" based on the defined scheduling strategy. This process ensures efficient resource allocation and utilization in the simulated cloud environment.</p>"},{"location":"api/scheduler/container_scheduler/#PyCloudSim.scheduler.container_scheduler.BestfitContainerScheduler","title":"<code>BestfitContainerScheduler</code>","text":"<p>             Bases: <code>ContainerScheduler</code></p> <p>Bestfit container scheduler. It will return the host with the least amount of resources.</p> Source code in <code>PyCloudSim\\scheduler\\container_scheduler.py</code> <pre><code>class BestfitContainerScheduler(ContainerScheduler):\n    \"\"\"Bestfit container scheduler. It will return the host with the least amount of resources.\"\"\"\n\n    def __init__(self) -&gt; None:\n        super().__init__()\n\n    def find_host(self, container: vContainer) -&gt; vHost | None:\n        simulation.hosts.sort(key=lambda host: host.rom_reservoir.amount)\n        simulation.hosts.sort(key=lambda host: host.ram_reservoir.amount)\n        simulation.hosts.sort(key=lambda host: host.cpu_reservoir.amount)\n        for host in simulation.hosts:\n            if (\n                host.powered_on\n                and host.ram_reservoir.amount &gt;= container.ram\n                and host.cpu_reservoir.amount &gt;= container.cpu\n                and host.rom_reservoir.amount &gt;= container.image_size\n            ):\n                return host\n</code></pre>"},{"location":"api/scheduler/container_scheduler/#PyCloudSim.scheduler.container_scheduler.ContainerScheduler","title":"<code>ContainerScheduler</code>","text":"<p>             Bases: <code>ABC</code>, <code>Entity</code></p> <p>Base for all container schedulers.</p> Source code in <code>PyCloudSim\\scheduler\\container_scheduler.py</code> <pre><code>class ContainerScheduler(ABC, Entity):\n    \"\"\"Base for all container schedulers.\"\"\"\n\n    def __init__(self) -&gt; None:\n        super().__init__(label=\"Container Scheduler\", create_at=0)\n        simulation._container_scheduler = self\n\n    def on_creation(self):\n        super().on_creation()\n\n        @self.continuous_event(\n            at=simulation.now,\n            interval=simulation.min_time_unit,\n            duration=inf,\n            label=\"Scheduling Containers\",\n            priority=inf,\n        )\n        def _scheduling():\n            simulation.containers.sort(key=lambda container: container.priority)\n            for container in simulation.containers:\n                # skip if container is already scheduled\n                if container.scheduled:\n                    continue\n\n                # skip if not all volumes are scheduled\n                if not all([volume.scheduled for volume in container.volumes]):\n                    continue\n\n                # find a host for the container\n                host = self.find_host(container)\n                # if a host is found, allocate the container to the host\n                if host:\n                    host.allocate_container(container)\n                else:\n                    logger.debug(\n                        f\"{simulation.now}:\\tContainer {container.label} cannot be scheduled.\"\n                    )\n\n    def on_termination(self):\n        return super().on_termination()\n\n    def on_destruction(self):\n        return super().on_destruction()\n\n    @abstractmethod\n    def find_host(self, container: vContainer) -&gt; vHost | None:\n        pass\n</code></pre>"},{"location":"api/scheduler/container_scheduler/#PyCloudSim.scheduler.container_scheduler.DefaultContainerScheduler","title":"<code>DefaultContainerScheduler</code>","text":"<p>             Bases: <code>ContainerScheduler</code></p> <p>Default container scheduler. It will return the first available host.</p> Source code in <code>PyCloudSim\\scheduler\\container_scheduler.py</code> <pre><code>class DefaultContainerScheduler(ContainerScheduler):\n    \"\"\"Default container scheduler. It will return the first available host.\"\"\"\n\n    def __init__(self) -&gt; None:\n        super().__init__()\n\n    def find_host(self, container: vContainer) -&gt; vHost | None:\n        for host in simulation.hosts:\n            if (\n                host.powered_on\n                and host.ram_reservoir.amount &gt;= container.ram\n                and host.cpu_reservoir.amount &gt;= container.cpu\n                and host.rom_reservoir.amount &gt;= container.image_size\n            ):\n                return host\n</code></pre>"},{"location":"api/scheduler/container_scheduler/#PyCloudSim.scheduler.container_scheduler.WorstfitContainerScheduler","title":"<code>WorstfitContainerScheduler</code>","text":"<p>             Bases: <code>ContainerScheduler</code></p> <p>Worstfit container scheduler. It will return the host with the most amount of resources.</p> Source code in <code>PyCloudSim\\scheduler\\container_scheduler.py</code> <pre><code>class WorstfitContainerScheduler(ContainerScheduler):\n    \"\"\"Worstfit container scheduler. It will return the host with the most amount of resources.\"\"\"\n\n    def __init__(self) -&gt; None:\n        super().__init__()\n\n    def find_host(self, container: vContainer) -&gt; vHost | None:\n        simulation.hosts.sort(key=lambda host: host.rom_reservoir.amount, reverse=True)\n        simulation.hosts.sort(key=lambda host: host.ram_reservoir.amount, reverse=True)\n        simulation.hosts.sort(key=lambda host: host.cpu_reservoir.amount, reverse=True)\n        for host in simulation.hosts:\n            if (\n                host.powered_on\n                and host.ram_reservoir.amount &gt;= container.ram\n                and host.cpu_reservoir.amount &gt;= container.cpu\n                and host.rom_reservoir.amount &gt;= container.image_size\n            ):\n                return host\n</code></pre>"},{"location":"api/scheduler/volume_scheduler/","title":"Volume Scheduler","text":"<p>The class \"vVolume\" is implemented to resemble a volume that can be attached to a container in Docker or Kubernetes which consumes the ROM from \"vHost\". A \"vContainer\" could be attached with multiple \"vVolume\" and those  \"vVolume\" could be allocated on different \"vHost\" rather than the \"vHost\" where the \"vContainer\" is hosted. The \"vVolume\" must be allocated first before a \"vContainer\" is scheduled. If any \"vVolume\" is failed to be allocated onto \"vHost\", the schedule of its associated \"vContainer\" will be on hold.</p>"},{"location":"api/scheduler/volume_scheduler/#PyCloudSim.scheduler.volume_scheduler.BestfitVolumeScheduler","title":"<code>BestfitVolumeScheduler</code>","text":"<p>             Bases: <code>VolumeScheduler</code></p> <p>Bestfit volume scheduler. It will return the host with the least amount of resources.</p> Source code in <code>PyCloudSim\\scheduler\\volume_scheduler.py</code> <pre><code>class BestfitVolumeScheduler(VolumeScheduler):\n    \"\"\"Bestfit volume scheduler. It will return the host with the least amount of resources.\"\"\"\n\n    def __init__(self) -&gt; None:\n        super().__init__()\n\n    def find_host(self, volume: vVolume) -&gt; vHost | None:\n        simulation.hosts.sort(key=lambda host: host.rom_reservoir.amount)\n        for host in simulation.hosts:\n            if host.powered_on and host.rom_reservoir.amount &gt;= volume.size:\n                return host\n</code></pre>"},{"location":"api/scheduler/volume_scheduler/#PyCloudSim.scheduler.volume_scheduler.DefaultVolumeScheduler","title":"<code>DefaultVolumeScheduler</code>","text":"<p>             Bases: <code>VolumeScheduler</code></p> <p>Default volume scheduler. It will return the first available host.</p> Source code in <code>PyCloudSim\\scheduler\\volume_scheduler.py</code> <pre><code>class DefaultVolumeScheduler(VolumeScheduler):\n    \"\"\"Default volume scheduler. It will return the first available host.\"\"\"\n\n    def __init__(self) -&gt; None:\n        super().__init__()\n\n    def find_host(self, volume: vVolume) -&gt; vHost | None:\n        for host in simulation.hosts:\n            if host.powered_on and host.rom_reservoir.amount &gt;= volume.size:\n                return host\n</code></pre>"},{"location":"api/scheduler/volume_scheduler/#PyCloudSim.scheduler.volume_scheduler.VolumeScheduler","title":"<code>VolumeScheduler</code>","text":"<p>             Bases: <code>ABC</code>, <code>Entity</code></p> <p>Base for all container schedulers.</p> Source code in <code>PyCloudSim\\scheduler\\volume_scheduler.py</code> <pre><code>class VolumeScheduler(ABC, Entity):\n    \"\"\"Base for all container schedulers.\"\"\"\n\n    def __init__(self) -&gt; None:\n        super().__init__(label=\"Volume Scheduler\", create_at=0, precursor=None)\n        simulation._volume_scheduler = self\n\n    def on_creation(self):\n        super().on_creation()\n\n        @self.continuous_event(\n            at=simulation.now,\n            interval=simulation.min_time_unit,\n            duration=inf,\n            label=\"Scheduling Volumes\",\n            priority=inf,\n        )\n        def scheduling():\n            for volume in simulation.volumes:\n                # skip if container is already scheduled\n                if volume.scheduled:\n                    continue\n\n                # find a host for the container\n                host = self.find_host(volume)\n                # if a host is found, allocate the container to the host\n                if host:\n                    host.allocate_volume(volume)\n                else:\n                    logger.debug(f\"{simulation.now}:\\t{volume} cannot be scheduled.\")\n\n    def on_termination(self):\n        return super().on_termination()\n\n    def on_destruction(self):\n        return super().on_destruction()\n\n    @abstractmethod\n    def find_host(self, volume: vVolume) -&gt; vHost | None:\n        pass\n</code></pre>"},{"location":"api/scheduler/volume_scheduler/#PyCloudSim.scheduler.volume_scheduler.WorstfitVolumeScheduler","title":"<code>WorstfitVolumeScheduler</code>","text":"<p>             Bases: <code>VolumeScheduler</code></p> <p>Worstfit volume scheduler. It will return the host with the most amount of resources.</p> Source code in <code>PyCloudSim\\scheduler\\volume_scheduler.py</code> <pre><code>class WorstfitVolumeScheduler(VolumeScheduler):\n    \"\"\"Worstfit volume scheduler. It will return the host with the most amount of resources.\"\"\"\n\n    def __init__(self) -&gt; None:\n        super().__init__()\n\n    def find_host(self, volume: vVolume) -&gt; vHost | None:\n        simulation.hosts.sort(key=lambda host: host.rom_reservoir.amount, reverse=True)\n        for host in simulation.hosts:\n            if host.powered_on and host.rom_reservoir.amount &gt;= volume.size:\n                return host\n</code></pre>"},{"location":"api/software_entity/","title":"Index","text":"<p>The abstract class \"VirtualEntity\" extends the \"Entity\" class and introduces additional statuses that are specific to virtual entities within the simulation context. These new statuses include \"initiated,\" \"scheduled,\" \"failed,\" and \"completed.\" These statuses are designed to capture different stages or outcomes relevant to virtual entities during the simulation process.</p>"},{"location":"api/software_entity/v_container/","title":"vContainer","text":"<p>The class \"vContainer\" serves as an implementation of the abstract class \"VirtualEntity\" and emulates containers in Docker or Pods in Kubernetes. It encompasses the following essential attributes and member functions:</p> <ol> <li>CPU: Represents the CPU time limit allocated to the \"vContainer\".</li> <li>RAM: Denotes the maximum amount of RAM that the \"vContainer\" can utilize.</li> <li>Simulated API Call Queue: Stores the simulated API calls associated with the \"vContainer\".</li> <li>Simulated Process Queue: Holds the simulated processes assigned to the \"vContainer\".</li> <li>Crash Handling: If the RAM consumed by all the simulated processes in the queue surpasses the container's RAM capacity, the \"vContainer\" will crash. Consequently, all processes in the queue will be terminated and marked as failed.</li> <li>Simulated Daemon Process: The \"vContainer\" may include a simulated daemon process that mimics resource usage when the container is idle. This daemon process operates continuously until the \"vContainer\" is terminated.</li> </ol> <p>Overall, the \"vContainer\" encapsulates the behavior and characteristics of containerized environments, providing capabilities for resource allocation, process management, and crash handling within the simulated cloud environment.</p> <p>             Bases: <code>vSoftwareEntity</code></p> Source code in <code>PyCloudSim\\entity\\v_container.py</code> <pre><code>class vContainer(vSoftwareEntity):\n    def __init__(\n        self,\n        cpu: int | Callable[..., int],\n        ram: int | Callable[..., int],\n        image_size: int | Callable[..., int],\n        cpu_limit: int | Callable[..., int] | None = None,\n        ram_limit: int | Callable[..., int] | None = None,\n        volumes: List[Tuple[int, str, str]] = [],\n        priority: int | Callable[..., int] = 0,\n        deamon: bool | Callable[..., bool] = False,\n        label: str | None = None,\n        create_at: int\n        | float\n        | Callable[..., int]\n        | Callable[..., float]\n        | None = None,\n        terminate_at: int\n        | float\n        | Callable[..., int]\n        | Callable[..., float]\n        | None = None,\n        precursor: Entity | List[Entity] | None = None,\n    ) -&gt; None:\n        \"\"\"Create a simulated container.\n\n        Args:\n            cpu (int | Callable[..., int]): the requested CPU of the container.\n            ram (int | Callable[..., int]): the requested RAM of the container.\n            image_size (int | Callable[..., int]): the image size of the container.\n            cpu_limit (int | Callable[..., int] | None, optional): the limited CPU of the container. Defaults to None, means there is no limitation.\n            ram_limit (int | Callable[..., int] | None, optional): the limited RAM of the container. Defaults to None, means there is no limitation.\n            priority (int | Callable[..., int], optional): the priority of the container. Defaults to 0.\n            deamon (bool | Callable[..., bool], optional): true if the container has a constantly running process. Defaults to False.\n            label (str | None, optional): the short description of the container. Defaults to None.\n            create_at (int | float | Callable[..., int] | Callable[..., float] | None, optional): when this container should be created. Defaults to None.\n            terminate_at (int | float | Callable[..., int] | Callable[..., float] | None, optional): when this container should be terminated. Defaults to None means it will not be terminated unless it is failed or termination is forced.\n            precursor (Entity | List[Entity] | None, optional): the entity that this container must not be created before. Defaults to None.\n        \"\"\"\n        super().__init__(label, create_at, terminate_at, precursor)\n\n        if callable(cpu):\n            self._cpu = round(cpu())\n        else:\n            self._cpu = cpu\n\n        if callable(ram):\n            self._ram = MiB(round(ram())).bytes\n        else:\n            self._ram = MiB(ram).bytes\n\n        if callable(image_size):\n            self._image_size = MiB(round(image_size())).bytes\n        else:\n            self._image_size = MiB(image_size).bytes\n\n        if callable(ram_limit):\n            self._ram_limit = MiB(round(ram_limit())).bytes\n        elif ram_limit is not None:\n            self._ram_limit = MiB(ram_limit).bytes\n        else:\n            self._ram_limit = inf\n\n        if callable(cpu_limit):\n            self._cpu_limit = round(cpu_limit())\n        elif cpu_limit is not None:\n            self._cpu_limit = cpu_limit\n        else:\n            self._cpu_limit = inf\n\n        self._volumes_descriptions = volumes\n        self._volumes = EntityList(label=f\"{self} Volumes\")\n\n        if callable(priority):\n            self._priority = round(priority())\n        else:\n            self._priority = priority\n\n        if callable(deamon):\n            self._deamon = deamon()\n        else:\n            self._deamon = deamon\n\n        self._host: vHost | None = None\n        self._deamon_process: vProcess | None = None\n        self._process_queue: List[vProcess] = EntityList(label=f\"{self} Process Queue\")\n        self._cpu_usage = 0.0\n        self._ram_usage = 0\n\n        simulation.containers.append(self)\n\n    def on_creation(self):\n        for volume_description in self._volumes_descriptions:\n            volume = vVolume(\n                size=volume_description[0],\n                path=volume_description[1],\n                label=volume_description[2],\n                create_at=simulation.now,\n            )\n            self.volumes.append(volume)\n\n        logger.info(f\"{simulation.now}:\\t{self} is created.\")\n\n    def on_termination(self):\n        for process in self.process_queue:\n            process.fail(simulation.now)\n        for volume in self.volumes:\n            volume.terminate(simulation.now)\n        logger.info(f\"{simulation.now}:\\t{self} is terminated.\")\n\n    def on_destruction(self):\n        for process in self.process_queue:\n            process.fail(simulation.now)\n        for volume in self.volumes:\n            volume.destroy(simulation.now)\n        logger.info(f\"{simulation.now}:\\t{self} is failed.\")\n\n    def on_success(self) -&gt; None:\n        super().on_success()\n\n    def on_fail(self) -&gt; None:\n        super().on_fail()\n        logger.info(f\"{simulation.now}:\\t{self} is failed.\")\n\n    def on_initiate(self):\n        \"\"\"Initiate the container.\"\"\"\n        super().on_initiate()\n        if self.host is None:\n            raise RuntimeError(f\"{self} can not be initiated without a host.\")\n        if self.deamon:\n            deamon_length = round(\n                (self.cpu / 1000) * self.host.cpu.ipc * self.host.cpu.frequency\n            )\n            self._deamon_process = vDeamon(\n                length=deamon_length,\n                container=self,\n                priority=-1,\n                label=f\"{self.label}\",\n                create_at=simulation.now,\n            )\n        logger.info(f\"{simulation.now}:\\t{self} is initiated.\")\n\n    @property\n    def cpu(self):\n        \"\"\"Return the requested CPU of the container.\"\"\"\n        return self._cpu\n\n    @property\n    def cpu_limit(self) -&gt; float | int:\n        \"\"\"Return the CPU limit of the container.\"\"\"\n        return self._cpu_limit\n\n    @property\n    def ram(self):\n        \"\"\"Return the requested RAM of the container.\"\"\"\n        return self._ram\n\n    @property\n    def ram_limit(self) -&gt; float | int:\n        \"\"\"Return the RAM limit of the container.\"\"\"\n        return self._ram_limit\n\n    @property\n    def image_size(self):\n        \"\"\"Return the image size of the container.\"\"\"\n        return self._image_size\n\n    @property\n    def priority(self):\n        \"\"\"Return the priority of the container.\"\"\"\n        return self._priority\n\n    @property\n    def scheduled(self):\n        \"\"\"Return whether the container has been scheduled.\"\"\"\n        return Constants.SCHEDULED in self.state\n\n    @property\n    def initiated(self):\n        \"\"\"Return whether the container has been initiated.\"\"\"\n        return Constants.INITIATED in self.state\n\n    @property\n    def deamon(self):\n        \"\"\"Return whether the container is a deamon.\"\"\"\n        return self._deamon\n\n    @property\n    def deamon_process(self):\n        \"\"\"Return the deamon process of the container.\"\"\"\n        return self._deamon_process\n\n    @property\n    def host(self):\n        \"\"\"Return the host of the container.\"\"\"\n        if self._host is None:\n            raise RuntimeError(f\"{self} has not been allocated on a host.\")\n        return self._host\n\n    @property\n    def cpu_usage(self):\n        \"\"\"Return the CPU usage of the container.\"\"\"\n        return self._cpu_usage\n\n    @property\n    def cpu_utilization(self):\n        \"\"\"Return the CPU utilization of the container.\"\"\"\n        return self._cpu_usage / self.cpu_limit\n\n    @property\n    def ram_usage(self):\n        \"\"\"Return the RAM usage of the container.\"\"\"\n        return self._ram_usage\n\n    @property\n    def ram_utilization(self):\n        \"\"\"Return the RAM utilization of the container.\"\"\"\n        return self._ram_usage / self.ram_limit\n\n    @property\n    def process_queue(self):\n        \"\"\"Return the process queue of the container.\"\"\"\n        return self._process_queue\n\n    @property\n    def volumes(self):\n        \"\"\"Return the volumes of the container.\"\"\"\n        return self._volumes\n</code></pre>"},{"location":"api/software_entity/v_container/#PyCloudSim.entity.v_container.vContainer.cpu","title":"<code>cpu</code>  <code>property</code>","text":"<p>Return the requested CPU of the container.</p>"},{"location":"api/software_entity/v_container/#PyCloudSim.entity.v_container.vContainer.cpu_limit","title":"<code>cpu_limit: float | int</code>  <code>property</code>","text":"<p>Return the CPU limit of the container.</p>"},{"location":"api/software_entity/v_container/#PyCloudSim.entity.v_container.vContainer.cpu_usage","title":"<code>cpu_usage</code>  <code>property</code>","text":"<p>Return the CPU usage of the container.</p>"},{"location":"api/software_entity/v_container/#PyCloudSim.entity.v_container.vContainer.cpu_utilization","title":"<code>cpu_utilization</code>  <code>property</code>","text":"<p>Return the CPU utilization of the container.</p>"},{"location":"api/software_entity/v_container/#PyCloudSim.entity.v_container.vContainer.deamon","title":"<code>deamon</code>  <code>property</code>","text":"<p>Return whether the container is a deamon.</p>"},{"location":"api/software_entity/v_container/#PyCloudSim.entity.v_container.vContainer.deamon_process","title":"<code>deamon_process</code>  <code>property</code>","text":"<p>Return the deamon process of the container.</p>"},{"location":"api/software_entity/v_container/#PyCloudSim.entity.v_container.vContainer.host","title":"<code>host</code>  <code>property</code>","text":"<p>Return the host of the container.</p>"},{"location":"api/software_entity/v_container/#PyCloudSim.entity.v_container.vContainer.image_size","title":"<code>image_size</code>  <code>property</code>","text":"<p>Return the image size of the container.</p>"},{"location":"api/software_entity/v_container/#PyCloudSim.entity.v_container.vContainer.initiated","title":"<code>initiated</code>  <code>property</code>","text":"<p>Return whether the container has been initiated.</p>"},{"location":"api/software_entity/v_container/#PyCloudSim.entity.v_container.vContainer.priority","title":"<code>priority</code>  <code>property</code>","text":"<p>Return the priority of the container.</p>"},{"location":"api/software_entity/v_container/#PyCloudSim.entity.v_container.vContainer.process_queue","title":"<code>process_queue</code>  <code>property</code>","text":"<p>Return the process queue of the container.</p>"},{"location":"api/software_entity/v_container/#PyCloudSim.entity.v_container.vContainer.ram","title":"<code>ram</code>  <code>property</code>","text":"<p>Return the requested RAM of the container.</p>"},{"location":"api/software_entity/v_container/#PyCloudSim.entity.v_container.vContainer.ram_limit","title":"<code>ram_limit: float | int</code>  <code>property</code>","text":"<p>Return the RAM limit of the container.</p>"},{"location":"api/software_entity/v_container/#PyCloudSim.entity.v_container.vContainer.ram_usage","title":"<code>ram_usage</code>  <code>property</code>","text":"<p>Return the RAM usage of the container.</p>"},{"location":"api/software_entity/v_container/#PyCloudSim.entity.v_container.vContainer.ram_utilization","title":"<code>ram_utilization</code>  <code>property</code>","text":"<p>Return the RAM utilization of the container.</p>"},{"location":"api/software_entity/v_container/#PyCloudSim.entity.v_container.vContainer.scheduled","title":"<code>scheduled</code>  <code>property</code>","text":"<p>Return whether the container has been scheduled.</p>"},{"location":"api/software_entity/v_container/#PyCloudSim.entity.v_container.vContainer.volumes","title":"<code>volumes</code>  <code>property</code>","text":"<p>Return the volumes of the container.</p>"},{"location":"api/software_entity/v_container/#PyCloudSim.entity.v_container.vContainer.__init__","title":"<code>__init__(cpu, ram, image_size, cpu_limit=None, ram_limit=None, volumes=[], priority=0, deamon=False, label=None, create_at=None, terminate_at=None, precursor=None)</code>","text":"<p>Create a simulated container.</p> <p>Parameters:</p> Name Type Description Default <code>cpu</code> <code>int | Callable[..., int]</code> <p>the requested CPU of the container.</p> required <code>ram</code> <code>int | Callable[..., int]</code> <p>the requested RAM of the container.</p> required <code>image_size</code> <code>int | Callable[..., int]</code> <p>the image size of the container.</p> required <code>cpu_limit</code> <code>int | Callable[..., int] | None</code> <p>the limited CPU of the container. Defaults to None, means there is no limitation.</p> <code>None</code> <code>ram_limit</code> <code>int | Callable[..., int] | None</code> <p>the limited RAM of the container. Defaults to None, means there is no limitation.</p> <code>None</code> <code>priority</code> <code>int | Callable[..., int]</code> <p>the priority of the container. Defaults to 0.</p> <code>0</code> <code>deamon</code> <code>bool | Callable[..., bool]</code> <p>true if the container has a constantly running process. Defaults to False.</p> <code>False</code> <code>label</code> <code>str | None</code> <p>the short description of the container. Defaults to None.</p> <code>None</code> <code>create_at</code> <code>int | float | Callable[..., int] | Callable[..., float] | None</code> <p>when this container should be created. Defaults to None.</p> <code>None</code> <code>terminate_at</code> <code>int | float | Callable[..., int] | Callable[..., float] | None</code> <p>when this container should be terminated. Defaults to None means it will not be terminated unless it is failed or termination is forced.</p> <code>None</code> <code>precursor</code> <code>Entity | List[Entity] | None</code> <p>the entity that this container must not be created before. Defaults to None.</p> <code>None</code> Source code in <code>PyCloudSim\\entity\\v_container.py</code> <pre><code>def __init__(\n    self,\n    cpu: int | Callable[..., int],\n    ram: int | Callable[..., int],\n    image_size: int | Callable[..., int],\n    cpu_limit: int | Callable[..., int] | None = None,\n    ram_limit: int | Callable[..., int] | None = None,\n    volumes: List[Tuple[int, str, str]] = [],\n    priority: int | Callable[..., int] = 0,\n    deamon: bool | Callable[..., bool] = False,\n    label: str | None = None,\n    create_at: int\n    | float\n    | Callable[..., int]\n    | Callable[..., float]\n    | None = None,\n    terminate_at: int\n    | float\n    | Callable[..., int]\n    | Callable[..., float]\n    | None = None,\n    precursor: Entity | List[Entity] | None = None,\n) -&gt; None:\n    \"\"\"Create a simulated container.\n\n    Args:\n        cpu (int | Callable[..., int]): the requested CPU of the container.\n        ram (int | Callable[..., int]): the requested RAM of the container.\n        image_size (int | Callable[..., int]): the image size of the container.\n        cpu_limit (int | Callable[..., int] | None, optional): the limited CPU of the container. Defaults to None, means there is no limitation.\n        ram_limit (int | Callable[..., int] | None, optional): the limited RAM of the container. Defaults to None, means there is no limitation.\n        priority (int | Callable[..., int], optional): the priority of the container. Defaults to 0.\n        deamon (bool | Callable[..., bool], optional): true if the container has a constantly running process. Defaults to False.\n        label (str | None, optional): the short description of the container. Defaults to None.\n        create_at (int | float | Callable[..., int] | Callable[..., float] | None, optional): when this container should be created. Defaults to None.\n        terminate_at (int | float | Callable[..., int] | Callable[..., float] | None, optional): when this container should be terminated. Defaults to None means it will not be terminated unless it is failed or termination is forced.\n        precursor (Entity | List[Entity] | None, optional): the entity that this container must not be created before. Defaults to None.\n    \"\"\"\n    super().__init__(label, create_at, terminate_at, precursor)\n\n    if callable(cpu):\n        self._cpu = round(cpu())\n    else:\n        self._cpu = cpu\n\n    if callable(ram):\n        self._ram = MiB(round(ram())).bytes\n    else:\n        self._ram = MiB(ram).bytes\n\n    if callable(image_size):\n        self._image_size = MiB(round(image_size())).bytes\n    else:\n        self._image_size = MiB(image_size).bytes\n\n    if callable(ram_limit):\n        self._ram_limit = MiB(round(ram_limit())).bytes\n    elif ram_limit is not None:\n        self._ram_limit = MiB(ram_limit).bytes\n    else:\n        self._ram_limit = inf\n\n    if callable(cpu_limit):\n        self._cpu_limit = round(cpu_limit())\n    elif cpu_limit is not None:\n        self._cpu_limit = cpu_limit\n    else:\n        self._cpu_limit = inf\n\n    self._volumes_descriptions = volumes\n    self._volumes = EntityList(label=f\"{self} Volumes\")\n\n    if callable(priority):\n        self._priority = round(priority())\n    else:\n        self._priority = priority\n\n    if callable(deamon):\n        self._deamon = deamon()\n    else:\n        self._deamon = deamon\n\n    self._host: vHost | None = None\n    self._deamon_process: vProcess | None = None\n    self._process_queue: List[vProcess] = EntityList(label=f\"{self} Process Queue\")\n    self._cpu_usage = 0.0\n    self._ram_usage = 0\n\n    simulation.containers.append(self)\n</code></pre>"},{"location":"api/software_entity/v_container/#PyCloudSim.entity.v_container.vContainer.on_initiate","title":"<code>on_initiate()</code>","text":"<p>Initiate the container.</p> Source code in <code>PyCloudSim\\entity\\v_container.py</code> <pre><code>def on_initiate(self):\n    \"\"\"Initiate the container.\"\"\"\n    super().on_initiate()\n    if self.host is None:\n        raise RuntimeError(f\"{self} can not be initiated without a host.\")\n    if self.deamon:\n        deamon_length = round(\n            (self.cpu / 1000) * self.host.cpu.ipc * self.host.cpu.frequency\n        )\n        self._deamon_process = vDeamon(\n            length=deamon_length,\n            container=self,\n            priority=-1,\n            label=f\"{self.label}\",\n            create_at=simulation.now,\n        )\n    logger.info(f\"{simulation.now}:\\t{self} is initiated.\")\n</code></pre>"},{"location":"api/software_entity/v_microservice/","title":"vMicroservice","text":"<p>The class \"vMicroservice\" is designed to resemble a deployment in Kubernetes, comprising one or more instances of the \"vContainer\" class. It encompasses the following important member functions and behaviours:</p> <ol> <li>Recovery of Failed vContainers: When any \"vContainer\" crashes or encounters a failure, the \"vMicroservice\" includes a member function that facilitates the recovery of these failed containers. This recovery process is initiated immediately after a container failure or after a specific delay, as determined by the simulation.</li> <li>Horizontal Scaling: The \"vMicroservice\" is responsible for horizontal scaling, which involves dynamically adjusting the number of \"vContainer\" instances based on certain conditions. If the overall CPU/RAM usage of all current \"vContainer\" instances exceeds a predetermined threshold, a new \"vContainer\" will be created to handle the increased workload. Conversely, if a \"vContainer\" is identified as being under-utilized, it may be forcibly terminated. Horizontal scaling is implemented as an event, and only one horizontal scaling event can occur per \"vMicroservice\" instance at any given time during the simulation.</li> <li>Readiness of vMicroservice: The readiness of a \"vMicroservice\" is determined by the number of current \"vContainer\" instances reaching the minimum required number. This minimum requirement ensures that the \"vMicroservice\" is considered ready for operation.</li> </ol> <p>In summary, the \"vMicroservice\" class emulates the behaviour of deployments in Kubernetes, facilitating the management of \"vContainer\" instances, recovery from failures, horizontal scaling, and readiness evaluation within the simulated cloud environment.</p> <p>             Bases: <code>vSoftwareEntity</code>, <code>ABC</code></p> Source code in <code>PyCloudSim\\entity\\v_microservice.py</code> <pre><code>class vMicroservice(vSoftwareEntity, ABC):\n    def __init__(\n        self,\n        cpu: int | Callable[..., int],\n        ram: int | Callable[..., int],\n        image_size: int | Callable[..., int],\n        cpu_limit: int | Callable[..., int] | None = None,\n        ram_limit: int | Callable[..., int] | None = None,\n        volumes: List[Tuple[int, str, str]] = [],\n        priority: int | Callable[..., int] = 0,\n        deamon: bool | Callable[..., bool] = False,\n        min_num_instances: int | Callable[..., int] = 1,\n        max_num_instances: int | Callable[..., int] = 3,\n        loadbalancer: vLoadbalancer = Bestfit(),\n        label: str | None = None,\n        create_at: int\n        | float\n        | Callable[..., int]\n        | Callable[..., float]\n        | None = None,\n        terminate_at: int\n        | float\n        | Callable[..., int]\n        | Callable[..., float]\n        | None = None,\n        precursor: Entity | List[Entity] | None = None,\n    ) -&gt; None:\n        \"\"\"Base for simulated microservices. It includes the horizontal scaling functionality.\"\"\"\n        super().__init__(label, create_at, terminate_at, precursor)\n\n        self._cpu = cpu\n        self._ram = ram\n        self._image_size = image_size\n        self._cpu_limit = cpu_limit\n        self._ram_limit = ram_limit\n        self._volume_descriptions = volumes\n        self._priority = priority\n        self._demmon = deamon\n        self._scaling = False\n\n        if callable(min_num_instances):\n            self._min_num_instances = round(min_num_instances())\n        else:\n            self._min_num_instances = min_num_instances\n\n        if callable(max_num_instances):\n            self._max_num_instances = round(max_num_instances())\n        else:\n            self._max_num_instances = max_num_instances\n\n        self._containers: List[vContainer] = EntityList(label=f\"{self} Containers\")\n\n        self._loadbalancer = loadbalancer\n\n        for _ in range(self._min_num_instances):\n            self.containers.append(\n                vContainer(\n                    self.cpu,\n                    self.ram,\n                    self.image_size,\n                    self.cpu_limit,\n                    self.ram_limit,\n                    self.volume_descriptions,\n                    self.priority,\n                    self.deamon,\n                    label=f\"{self.label}-{len(self._containers)}\",\n                )\n            )\n\n    def horizontal_scale_up(self, num_instances: int, at: int | float):\n        \"\"\"Horizontal scale up the microservice by adding new container instances.\"\"\"\n\n        if self.scaling:\n            return\n\n        self._scaling = True\n\n        @self.instant_event(at, label=f\"{self} Horizontal Scale Up\", priority=-1)\n        def _scale_up():\n            for _ in range(num_instances):\n                self.containers.append(\n                    vContainer(\n                        self.cpu,\n                        self.ram,\n                        self.image_size,\n                        self.cpu_limit,\n                        self.ram_limit,\n                        self.volume_descriptions,\n                        self.priority,\n                        self.deamon,\n                        label=f\"{self.label}-{len(self._containers)}\",\n                        create_at=simulation.now,\n                    )\n                )\n            self._scaling = False\n\n    def horizontal_scale_down(self, num_instances: int, at: int | float):\n        \"\"\"Horizontal scale down the microservice by terminating container instances. This can not cause the number of container instances to be less than the minimum number of instances.\"\"\"\n        if self.scaling:\n            return\n\n        self._scaling = True\n\n        @self.instant_event(at, label=f\"{self} Horizontal Scale Down\", priority=-1)\n        def _scale_down():\n            for i in range(\n                min([num_instances, len(self.containers) - self.min_num_instances])\n            ):\n                self.containers[i].terminate(simulation.now)\n\n    def vertical_scale(\n        self,\n        at: int | float,\n        cpu: int | Callable[..., int],\n        ram: int | Callable[..., int],\n        image_size: int | Callable[..., int],\n        cpu_limit: int | Callable[..., int] | None = None,\n        ram_limit: int | Callable[..., int] | None = None,\n        init_delay: int | float | Callable[..., int] | Callable[..., float] = 0,\n        priority: int | Callable[..., int] = 0,\n        deamon: bool | Callable[..., bool] = False,\n        min_num_instances: int | Callable[..., int] = 1,\n        max_num_instances: int | Callable[..., int] = 3,\n        evaluation_interval: int\n        | float\n        | Callable[..., int]\n        | Callable[..., float] = 0.1,\n        cpu_upper_threshold: float | Callable[..., float] = 0.8,\n        cpu_lower_threshold: float | Callable[..., float] = 0.2,\n        ram_upper_threshold: float | Callable[..., float] = 0.8,\n        ram_lower_threshold: float | Callable[..., float] = 0.2,\n    ):\n        \"\"\"Scaling the microservice vertically by changing the attributes of the microservice. This will terminate all the current container instances and create new container instances with the new attributes.\"\"\"\n\n        @self.instant_event(at, label=f\"{self} Vertical Scale\", priority=-1)\n        def _vertical_scale():\n            # update the attributes\n            self._cpu = cpu\n            self._ram = ram\n            self._image_size = image_size\n            self._cpu_limit = cpu_limit\n            self._ram_limit = ram_limit\n            self._priority = priority\n            self._demmon = deamon\n            self._scaling = False\n\n            if callable(min_num_instances):\n                self._min_num_instances = round(min_num_instances())\n            else:\n                self._min_num_instances = min_num_instances\n\n            if callable(max_num_instances):\n                self._max_num_instances = round(max_num_instances())\n            else:\n                self._max_num_instances = max_num_instances\n\n            # record the current number of instances\n            number_instance = len(self.containers)\n            # terminate all the current instances\n            for container in self.containers:\n                container.terminate(simulation.now)\n            # create new instances\n            for _ in range(number_instance):\n                self.containers.append(\n                    vContainer(\n                        self.cpu,\n                        self.ram,\n                        self.image_size,\n                        self.cpu_limit,\n                        self.ram_limit,\n                        self.volume_descriptions,\n                        self.priority,\n                        self.deamon,\n                        label=f\"{self.label}-{len(self._containers)}\",\n                        create_at=simulation.now,\n                    )\n                )\n\n    @abstractmethod\n    def horizontal_scale_up_triggered(self) -&gt; bool:\n        \"\"\"Abstract method for evaluating if the microservice should be scaled up horizontally.\"\"\"\n        pass\n\n    @abstractmethod\n    def horizontal_scale_down_triggered(self) -&gt; bool:\n        \"\"\"Abstract method for evaluating if the microservice should be scaled down horizontally.\"\"\"\n        pass\n\n    def getContainer(self):\n        \"\"\"Get the container instance according to the loadbalancer.\"\"\"\n        return self.loadbalancer.getContainer(self)\n\n    def on_creation(self):\n        \"\"\"Creation procedure of the microservice. It will create the container instances and the evaluator.\"\"\"\n        for container in self._containers:\n            container.create(simulation.now)\n\n        @self.continuous_event(\n            at=simulation.now,\n            interval=simulation.min_time_unit,\n            duration=inf,\n            label=f\"{self} Evaluator\",\n        )\n        def _evaluator():\n            initiated_containers = [\n                container for container in self._containers if container.initiated\n            ]\n            # check if the microservice is ready\n            if len(initiated_containers) &lt; self.min_num_instances:\n                if self.ready:\n                    self.state.remove(Constants.READY)\n                    for _ in range(self.min_num_instances - len(initiated_containers)):\n                        self.containers.append(\n                            vContainer(\n                                self.cpu,\n                                self.ram,\n                                self.image_size,\n                                self.cpu_limit,\n                                self.ram_limit,\n                                self.volume_descriptions,\n                                self.priority,\n                                self.deamon,\n                                label=f\"{self.label}-{len(self._containers)}\",\n                                create_at=simulation.now,\n                            )\n                        )\n                    logger.info(f\"{simulation.now}:\\t{self} is not ready, recreating {self.min_num_instances - len(initiated_containers)} container instances\")\n                return\n            else:\n                if not self.ready:\n                    self.state.append(Constants.READY)\n                    logger.info(f\"{simulation.now}:\\t{self} is ready\")\n\n            # check if any container instance is pending:\n            if len(initiated_containers) != len(self.containers):\n                # if any instance is pending, skip the scaling evaluation\n                return\n\n            # check if the microservice should be scaled up\n            if len(self.containers) &lt; self.max_num_instances:\n                if self.horizontal_scale_up_triggered():\n                    self.horizontal_scale_up(1, simulation.now)\n                    return\n\n            # check if the microservice should be scaled down\n            if len(self.containers) &gt; self.min_num_instances:\n                if self.horizontal_scale_down_triggered():\n                    self.horizontal_scale_down(1, simulation.now)\n                    return\n\n    def on_termination(self):\n        for container in self._containers:\n            container.terminate(simulation.now)\n\n    @property\n    def cpu(self):\n        \"\"\"Return the required CPU time for each container instance.\"\"\"\n        return self._cpu\n\n    @property\n    def ram(self):\n        \"\"\"Return the required RAM for each container instance.\"\"\"\n        return self._ram\n\n    @property\n    def image_size(self):\n        \"\"\"Return the image size for each container instance.\"\"\"\n        return self._image_size\n\n    @property\n    def cpu_limit(self):\n        \"\"\"Return the CPU limit for each container instance.\"\"\"\n        return self._cpu_limit\n\n    @property\n    def ram_limit(self):\n        \"\"\"Return the RAM limit for each container instance.\"\"\"\n        return self._ram_limit\n\n    @property\n    def priority(self):\n        \"\"\"Return the priority for each container instance.\"\"\"\n        return self._priority\n\n    @property\n    def deamon(self):\n        \"\"\"Return the deamon flag for each container instance.\"\"\"\n        return self._demmon\n\n    @property\n    def min_num_instances(self):\n        \"\"\"Return the minimum number of container instances.\"\"\"\n        return self._min_num_instances\n\n    @property\n    def max_num_instances(self):\n        \"\"\"Return the maximum number of container instances.\"\"\"\n        return self._max_num_instances\n\n    @property\n    def containers(self):\n        \"\"\"Return the list of container instances.\"\"\"\n        return self._containers\n\n    @property\n    def cpu_usage(self):\n        \"\"\"Return the overall CPU usage of the microservice.\"\"\"\n        return sum(\n            container.cpu_usage for container in self._containers if container.initiated\n        )\n\n    @property\n    def cpu_utilization(self):\n        \"\"\"Return the overall CPU utilization of the microservice.\"\"\"\n        return sum(\n            container.cpu_utilization\n            for container in self._containers\n            if container.initiated\n        ) / len(self.containers)\n\n    @property\n    def ram_usage(self):\n        \"\"\"Return the overall RAM usage of the microservice.\"\"\"\n        return sum(\n            container.ram_usage for container in self._containers if container.initiated\n        )\n\n    @property\n    def ram_utilization(self):\n        \"\"\"Return the overall RAM utilization of the microservice.\"\"\"\n        return sum(\n            container.ram_utilization\n            for container in self._containers\n            if container.initiated\n        ) / len(self.containers)\n\n    @property\n    def num_active_containers(self):\n        \"\"\"Return the number of container instances.\"\"\"\n        active_containers = [container for container in self.containers if container.initiated]\n        return len(active_containers)\n\n    @property\n    def scaling(self):\n        \"\"\"Return true if the microservice is scaling up or down.\"\"\"\n        return self._scaling\n\n    @property\n    def ready(self):\n        \"\"\"Return true if the microservice is ready.\"\"\"\n        return Constants.READY in self.state\n\n    @property\n    def loadbalancer(self):\n        \"\"\"Return the loadbalancer of the microservice.\"\"\"\n        return self._loadbalancer\n\n    @property\n    def volume_descriptions(self):\n        \"\"\"Return the volume descriptions of the microservice.\"\"\"\n        return self._volume_descriptions\n</code></pre>"},{"location":"api/software_entity/v_microservice/#PyCloudSim.entity.v_microservice.vMicroservice.containers","title":"<code>containers</code>  <code>property</code>","text":"<p>Return the list of container instances.</p>"},{"location":"api/software_entity/v_microservice/#PyCloudSim.entity.v_microservice.vMicroservice.cpu","title":"<code>cpu</code>  <code>property</code>","text":"<p>Return the required CPU time for each container instance.</p>"},{"location":"api/software_entity/v_microservice/#PyCloudSim.entity.v_microservice.vMicroservice.cpu_limit","title":"<code>cpu_limit</code>  <code>property</code>","text":"<p>Return the CPU limit for each container instance.</p>"},{"location":"api/software_entity/v_microservice/#PyCloudSim.entity.v_microservice.vMicroservice.cpu_usage","title":"<code>cpu_usage</code>  <code>property</code>","text":"<p>Return the overall CPU usage of the microservice.</p>"},{"location":"api/software_entity/v_microservice/#PyCloudSim.entity.v_microservice.vMicroservice.cpu_utilization","title":"<code>cpu_utilization</code>  <code>property</code>","text":"<p>Return the overall CPU utilization of the microservice.</p>"},{"location":"api/software_entity/v_microservice/#PyCloudSim.entity.v_microservice.vMicroservice.deamon","title":"<code>deamon</code>  <code>property</code>","text":"<p>Return the deamon flag for each container instance.</p>"},{"location":"api/software_entity/v_microservice/#PyCloudSim.entity.v_microservice.vMicroservice.image_size","title":"<code>image_size</code>  <code>property</code>","text":"<p>Return the image size for each container instance.</p>"},{"location":"api/software_entity/v_microservice/#PyCloudSim.entity.v_microservice.vMicroservice.loadbalancer","title":"<code>loadbalancer</code>  <code>property</code>","text":"<p>Return the loadbalancer of the microservice.</p>"},{"location":"api/software_entity/v_microservice/#PyCloudSim.entity.v_microservice.vMicroservice.max_num_instances","title":"<code>max_num_instances</code>  <code>property</code>","text":"<p>Return the maximum number of container instances.</p>"},{"location":"api/software_entity/v_microservice/#PyCloudSim.entity.v_microservice.vMicroservice.min_num_instances","title":"<code>min_num_instances</code>  <code>property</code>","text":"<p>Return the minimum number of container instances.</p>"},{"location":"api/software_entity/v_microservice/#PyCloudSim.entity.v_microservice.vMicroservice.num_active_containers","title":"<code>num_active_containers</code>  <code>property</code>","text":"<p>Return the number of container instances.</p>"},{"location":"api/software_entity/v_microservice/#PyCloudSim.entity.v_microservice.vMicroservice.priority","title":"<code>priority</code>  <code>property</code>","text":"<p>Return the priority for each container instance.</p>"},{"location":"api/software_entity/v_microservice/#PyCloudSim.entity.v_microservice.vMicroservice.ram","title":"<code>ram</code>  <code>property</code>","text":"<p>Return the required RAM for each container instance.</p>"},{"location":"api/software_entity/v_microservice/#PyCloudSim.entity.v_microservice.vMicroservice.ram_limit","title":"<code>ram_limit</code>  <code>property</code>","text":"<p>Return the RAM limit for each container instance.</p>"},{"location":"api/software_entity/v_microservice/#PyCloudSim.entity.v_microservice.vMicroservice.ram_usage","title":"<code>ram_usage</code>  <code>property</code>","text":"<p>Return the overall RAM usage of the microservice.</p>"},{"location":"api/software_entity/v_microservice/#PyCloudSim.entity.v_microservice.vMicroservice.ram_utilization","title":"<code>ram_utilization</code>  <code>property</code>","text":"<p>Return the overall RAM utilization of the microservice.</p>"},{"location":"api/software_entity/v_microservice/#PyCloudSim.entity.v_microservice.vMicroservice.ready","title":"<code>ready</code>  <code>property</code>","text":"<p>Return true if the microservice is ready.</p>"},{"location":"api/software_entity/v_microservice/#PyCloudSim.entity.v_microservice.vMicroservice.scaling","title":"<code>scaling</code>  <code>property</code>","text":"<p>Return true if the microservice is scaling up or down.</p>"},{"location":"api/software_entity/v_microservice/#PyCloudSim.entity.v_microservice.vMicroservice.volume_descriptions","title":"<code>volume_descriptions</code>  <code>property</code>","text":"<p>Return the volume descriptions of the microservice.</p>"},{"location":"api/software_entity/v_microservice/#PyCloudSim.entity.v_microservice.vMicroservice.__init__","title":"<code>__init__(cpu, ram, image_size, cpu_limit=None, ram_limit=None, volumes=[], priority=0, deamon=False, min_num_instances=1, max_num_instances=3, loadbalancer=Bestfit(), label=None, create_at=None, terminate_at=None, precursor=None)</code>","text":"<p>Base for simulated microservices. It includes the horizontal scaling functionality.</p> Source code in <code>PyCloudSim\\entity\\v_microservice.py</code> <pre><code>def __init__(\n    self,\n    cpu: int | Callable[..., int],\n    ram: int | Callable[..., int],\n    image_size: int | Callable[..., int],\n    cpu_limit: int | Callable[..., int] | None = None,\n    ram_limit: int | Callable[..., int] | None = None,\n    volumes: List[Tuple[int, str, str]] = [],\n    priority: int | Callable[..., int] = 0,\n    deamon: bool | Callable[..., bool] = False,\n    min_num_instances: int | Callable[..., int] = 1,\n    max_num_instances: int | Callable[..., int] = 3,\n    loadbalancer: vLoadbalancer = Bestfit(),\n    label: str | None = None,\n    create_at: int\n    | float\n    | Callable[..., int]\n    | Callable[..., float]\n    | None = None,\n    terminate_at: int\n    | float\n    | Callable[..., int]\n    | Callable[..., float]\n    | None = None,\n    precursor: Entity | List[Entity] | None = None,\n) -&gt; None:\n    \"\"\"Base for simulated microservices. It includes the horizontal scaling functionality.\"\"\"\n    super().__init__(label, create_at, terminate_at, precursor)\n\n    self._cpu = cpu\n    self._ram = ram\n    self._image_size = image_size\n    self._cpu_limit = cpu_limit\n    self._ram_limit = ram_limit\n    self._volume_descriptions = volumes\n    self._priority = priority\n    self._demmon = deamon\n    self._scaling = False\n\n    if callable(min_num_instances):\n        self._min_num_instances = round(min_num_instances())\n    else:\n        self._min_num_instances = min_num_instances\n\n    if callable(max_num_instances):\n        self._max_num_instances = round(max_num_instances())\n    else:\n        self._max_num_instances = max_num_instances\n\n    self._containers: List[vContainer] = EntityList(label=f\"{self} Containers\")\n\n    self._loadbalancer = loadbalancer\n\n    for _ in range(self._min_num_instances):\n        self.containers.append(\n            vContainer(\n                self.cpu,\n                self.ram,\n                self.image_size,\n                self.cpu_limit,\n                self.ram_limit,\n                self.volume_descriptions,\n                self.priority,\n                self.deamon,\n                label=f\"{self.label}-{len(self._containers)}\",\n            )\n        )\n</code></pre>"},{"location":"api/software_entity/v_microservice/#PyCloudSim.entity.v_microservice.vMicroservice.getContainer","title":"<code>getContainer()</code>","text":"<p>Get the container instance according to the loadbalancer.</p> Source code in <code>PyCloudSim\\entity\\v_microservice.py</code> <pre><code>def getContainer(self):\n    \"\"\"Get the container instance according to the loadbalancer.\"\"\"\n    return self.loadbalancer.getContainer(self)\n</code></pre>"},{"location":"api/software_entity/v_microservice/#PyCloudSim.entity.v_microservice.vMicroservice.horizontal_scale_down","title":"<code>horizontal_scale_down(num_instances, at)</code>","text":"<p>Horizontal scale down the microservice by terminating container instances. This can not cause the number of container instances to be less than the minimum number of instances.</p> Source code in <code>PyCloudSim\\entity\\v_microservice.py</code> <pre><code>def horizontal_scale_down(self, num_instances: int, at: int | float):\n    \"\"\"Horizontal scale down the microservice by terminating container instances. This can not cause the number of container instances to be less than the minimum number of instances.\"\"\"\n    if self.scaling:\n        return\n\n    self._scaling = True\n\n    @self.instant_event(at, label=f\"{self} Horizontal Scale Down\", priority=-1)\n    def _scale_down():\n        for i in range(\n            min([num_instances, len(self.containers) - self.min_num_instances])\n        ):\n            self.containers[i].terminate(simulation.now)\n</code></pre>"},{"location":"api/software_entity/v_microservice/#PyCloudSim.entity.v_microservice.vMicroservice.horizontal_scale_down_triggered","title":"<code>horizontal_scale_down_triggered()</code>  <code>abstractmethod</code>","text":"<p>Abstract method for evaluating if the microservice should be scaled down horizontally.</p> Source code in <code>PyCloudSim\\entity\\v_microservice.py</code> <pre><code>@abstractmethod\ndef horizontal_scale_down_triggered(self) -&gt; bool:\n    \"\"\"Abstract method for evaluating if the microservice should be scaled down horizontally.\"\"\"\n    pass\n</code></pre>"},{"location":"api/software_entity/v_microservice/#PyCloudSim.entity.v_microservice.vMicroservice.horizontal_scale_up","title":"<code>horizontal_scale_up(num_instances, at)</code>","text":"<p>Horizontal scale up the microservice by adding new container instances.</p> Source code in <code>PyCloudSim\\entity\\v_microservice.py</code> <pre><code>def horizontal_scale_up(self, num_instances: int, at: int | float):\n    \"\"\"Horizontal scale up the microservice by adding new container instances.\"\"\"\n\n    if self.scaling:\n        return\n\n    self._scaling = True\n\n    @self.instant_event(at, label=f\"{self} Horizontal Scale Up\", priority=-1)\n    def _scale_up():\n        for _ in range(num_instances):\n            self.containers.append(\n                vContainer(\n                    self.cpu,\n                    self.ram,\n                    self.image_size,\n                    self.cpu_limit,\n                    self.ram_limit,\n                    self.volume_descriptions,\n                    self.priority,\n                    self.deamon,\n                    label=f\"{self.label}-{len(self._containers)}\",\n                    create_at=simulation.now,\n                )\n            )\n        self._scaling = False\n</code></pre>"},{"location":"api/software_entity/v_microservice/#PyCloudSim.entity.v_microservice.vMicroservice.horizontal_scale_up_triggered","title":"<code>horizontal_scale_up_triggered()</code>  <code>abstractmethod</code>","text":"<p>Abstract method for evaluating if the microservice should be scaled up horizontally.</p> Source code in <code>PyCloudSim\\entity\\v_microservice.py</code> <pre><code>@abstractmethod\ndef horizontal_scale_up_triggered(self) -&gt; bool:\n    \"\"\"Abstract method for evaluating if the microservice should be scaled up horizontally.\"\"\"\n    pass\n</code></pre>"},{"location":"api/software_entity/v_microservice/#PyCloudSim.entity.v_microservice.vMicroservice.on_creation","title":"<code>on_creation()</code>","text":"<p>Creation procedure of the microservice. It will create the container instances and the evaluator.</p> Source code in <code>PyCloudSim\\entity\\v_microservice.py</code> <pre><code>def on_creation(self):\n    \"\"\"Creation procedure of the microservice. It will create the container instances and the evaluator.\"\"\"\n    for container in self._containers:\n        container.create(simulation.now)\n\n    @self.continuous_event(\n        at=simulation.now,\n        interval=simulation.min_time_unit,\n        duration=inf,\n        label=f\"{self} Evaluator\",\n    )\n    def _evaluator():\n        initiated_containers = [\n            container for container in self._containers if container.initiated\n        ]\n        # check if the microservice is ready\n        if len(initiated_containers) &lt; self.min_num_instances:\n            if self.ready:\n                self.state.remove(Constants.READY)\n                for _ in range(self.min_num_instances - len(initiated_containers)):\n                    self.containers.append(\n                        vContainer(\n                            self.cpu,\n                            self.ram,\n                            self.image_size,\n                            self.cpu_limit,\n                            self.ram_limit,\n                            self.volume_descriptions,\n                            self.priority,\n                            self.deamon,\n                            label=f\"{self.label}-{len(self._containers)}\",\n                            create_at=simulation.now,\n                        )\n                    )\n                logger.info(f\"{simulation.now}:\\t{self} is not ready, recreating {self.min_num_instances - len(initiated_containers)} container instances\")\n            return\n        else:\n            if not self.ready:\n                self.state.append(Constants.READY)\n                logger.info(f\"{simulation.now}:\\t{self} is ready\")\n\n        # check if any container instance is pending:\n        if len(initiated_containers) != len(self.containers):\n            # if any instance is pending, skip the scaling evaluation\n            return\n\n        # check if the microservice should be scaled up\n        if len(self.containers) &lt; self.max_num_instances:\n            if self.horizontal_scale_up_triggered():\n                self.horizontal_scale_up(1, simulation.now)\n                return\n\n        # check if the microservice should be scaled down\n        if len(self.containers) &gt; self.min_num_instances:\n            if self.horizontal_scale_down_triggered():\n                self.horizontal_scale_down(1, simulation.now)\n                return\n</code></pre>"},{"location":"api/software_entity/v_microservice/#PyCloudSim.entity.v_microservice.vMicroservice.vertical_scale","title":"<code>vertical_scale(at, cpu, ram, image_size, cpu_limit=None, ram_limit=None, init_delay=0, priority=0, deamon=False, min_num_instances=1, max_num_instances=3, evaluation_interval=0.1, cpu_upper_threshold=0.8, cpu_lower_threshold=0.2, ram_upper_threshold=0.8, ram_lower_threshold=0.2)</code>","text":"<p>Scaling the microservice vertically by changing the attributes of the microservice. This will terminate all the current container instances and create new container instances with the new attributes.</p> Source code in <code>PyCloudSim\\entity\\v_microservice.py</code> <pre><code>def vertical_scale(\n    self,\n    at: int | float,\n    cpu: int | Callable[..., int],\n    ram: int | Callable[..., int],\n    image_size: int | Callable[..., int],\n    cpu_limit: int | Callable[..., int] | None = None,\n    ram_limit: int | Callable[..., int] | None = None,\n    init_delay: int | float | Callable[..., int] | Callable[..., float] = 0,\n    priority: int | Callable[..., int] = 0,\n    deamon: bool | Callable[..., bool] = False,\n    min_num_instances: int | Callable[..., int] = 1,\n    max_num_instances: int | Callable[..., int] = 3,\n    evaluation_interval: int\n    | float\n    | Callable[..., int]\n    | Callable[..., float] = 0.1,\n    cpu_upper_threshold: float | Callable[..., float] = 0.8,\n    cpu_lower_threshold: float | Callable[..., float] = 0.2,\n    ram_upper_threshold: float | Callable[..., float] = 0.8,\n    ram_lower_threshold: float | Callable[..., float] = 0.2,\n):\n    \"\"\"Scaling the microservice vertically by changing the attributes of the microservice. This will terminate all the current container instances and create new container instances with the new attributes.\"\"\"\n\n    @self.instant_event(at, label=f\"{self} Vertical Scale\", priority=-1)\n    def _vertical_scale():\n        # update the attributes\n        self._cpu = cpu\n        self._ram = ram\n        self._image_size = image_size\n        self._cpu_limit = cpu_limit\n        self._ram_limit = ram_limit\n        self._priority = priority\n        self._demmon = deamon\n        self._scaling = False\n\n        if callable(min_num_instances):\n            self._min_num_instances = round(min_num_instances())\n        else:\n            self._min_num_instances = min_num_instances\n\n        if callable(max_num_instances):\n            self._max_num_instances = round(max_num_instances())\n        else:\n            self._max_num_instances = max_num_instances\n\n        # record the current number of instances\n        number_instance = len(self.containers)\n        # terminate all the current instances\n        for container in self.containers:\n            container.terminate(simulation.now)\n        # create new instances\n        for _ in range(number_instance):\n            self.containers.append(\n                vContainer(\n                    self.cpu,\n                    self.ram,\n                    self.image_size,\n                    self.cpu_limit,\n                    self.ram_limit,\n                    self.volume_descriptions,\n                    self.priority,\n                    self.deamon,\n                    label=f\"{self.label}-{len(self._containers)}\",\n                    create_at=simulation.now,\n                )\n            )\n</code></pre>"},{"location":"api/software_entity/v_microservice/#default-vmicroservice","title":"Default vMicroservice","text":"<p>             Bases: <code>vMicroservice</code></p> Source code in <code>PyCloudSim\\entity\\v_microservice.py</code> <pre><code>class vDefaultMicroservice(vMicroservice):\n    def __init__(\n        self,\n        cpu: int | Callable[..., int],\n        ram: int | Callable[..., int],\n        image_size: int | Callable[..., int],\n        cpu_limit: int | Callable[..., int] | None = None,\n        ram_limit: int | Callable[..., int] | None = None,\n        volumes: List[Tuple[int, str, str]] = [],\n        priority: int | Callable[..., int] = 0,\n        deamon: bool | Callable[..., bool] = False,\n        min_num_instances: int | Callable[..., int] = 1,\n        max_num_instances: int | Callable[..., int] = 3,\n        loadbalancer: vLoadbalancer = Bestfit(),\n        evaluation_interval: int\n        | float\n        | Callable[..., int]\n        | Callable[..., float] = 0.1,\n        cpu_upper_threshold: float | Callable[..., float] = 0.8,\n        cpu_lower_threshold: float | Callable[..., float] = 0.2,\n        ram_upper_threshold: float | Callable[..., float] = 0.8,\n        ram_lower_threshold: float | Callable[..., float] = 0.2,\n        label: str | None = None,\n        create_at: int\n        | float\n        | Callable[..., int]\n        | Callable[..., float]\n        | None = None,\n        terminate_at: int\n        | float\n        | Callable[..., int]\n        | Callable[..., float]\n        | None = None,\n        precursor: Entity | List[Entity] | None = None,\n    ) -&gt; None:\n        \"\"\"Default microservice. It will scale up if CPU or RAM utilization reached upper threshold. It will scale down if CPU and RAM utilization reached lower threshold.\"\"\"\n        super().__init__(\n            cpu,\n            ram,\n            image_size,\n            cpu_limit,\n            ram_limit,\n            volumes,\n            priority,\n            deamon,\n            min_num_instances,\n            max_num_instances,\n            loadbalancer,\n            label,\n            create_at,\n            terminate_at,\n            precursor,\n        )\n\n        if callable(cpu_upper_threshold):\n            self._cpu_upper_threshold = cpu_upper_threshold()\n        else:\n            self._cpu_upper_threshold = cpu_upper_threshold\n\n        if callable(cpu_lower_threshold):\n            self._cpu_lower_threshold = cpu_lower_threshold()\n        else:\n            self._cpu_lower_threshold = cpu_lower_threshold\n\n        if callable(ram_upper_threshold):\n            self._ram_upper_threshold = ram_upper_threshold()\n        else:\n            self._ram_upper_threshold = ram_upper_threshold\n\n        if callable(ram_lower_threshold):\n            self._ram_lower_threshold = ram_lower_threshold()\n        else:\n            self._ram_lower_threshold = ram_lower_threshold\n\n    def horizontal_scale_up_triggered(self) -&gt; bool:\n        \"\"\"The microservice will be scaled up if CPU or RAM utilization reached upper threshold.\"\"\"\n        if (\n            self.cpu_utilization &gt;= self.cpu_upper_threshold\n            or self.ram_utilization &gt;= self.ram_upper_threshold\n        ):\n            return True\n        else:\n            return False\n\n    def horizontal_scale_down_triggered(self) -&gt; bool:\n        \"\"\"The microservice will be scaled down if CPU and RAM utilization reached lower threshold.\"\"\"\n        if (\n            self.cpu_utilization &lt;= self.cpu_lower_threshold\n            and self.ram_utilization &lt;= self.ram_lower_threshold\n        ):\n            return True\n        else:\n            return False\n\n    @property\n    def cpu_upper_threshold(self):\n        \"\"\"Return the CPU upper threshold. If CPU utilization reached this threshold, the microservice will be scaled up.\"\"\"\n        return self._cpu_upper_threshold\n\n    @property\n    def cpu_lower_threshold(self):\n        \"\"\"Return the CPU lower threshold. If CPU utilization reached this threshold, the microservice will be scaled down (if RAM utilization also reached lower threshold).\"\"\"\n        return self._cpu_lower_threshold\n\n    @property\n    def ram_upper_threshold(self):\n        \"\"\"Return the RAM upper threshold. If RAM utilization reached this threshold, the microservice will be scaled up.\"\"\"\n        return self._ram_upper_threshold\n\n    @property\n    def ram_lower_threshold(self):\n        \"\"\"Return the RAM lower threshold. If RAM utilization reached this threshold, the microservice will be scaled down (if CPU utilization also reached lower threshold).\"\"\"\n        return self._ram_lower_threshold\n</code></pre>"},{"location":"api/software_entity/v_microservice/#PyCloudSim.entity.v_microservice.vDefaultMicroservice.cpu_lower_threshold","title":"<code>cpu_lower_threshold</code>  <code>property</code>","text":"<p>Return the CPU lower threshold. If CPU utilization reached this threshold, the microservice will be scaled down (if RAM utilization also reached lower threshold).</p>"},{"location":"api/software_entity/v_microservice/#PyCloudSim.entity.v_microservice.vDefaultMicroservice.cpu_upper_threshold","title":"<code>cpu_upper_threshold</code>  <code>property</code>","text":"<p>Return the CPU upper threshold. If CPU utilization reached this threshold, the microservice will be scaled up.</p>"},{"location":"api/software_entity/v_microservice/#PyCloudSim.entity.v_microservice.vDefaultMicroservice.ram_lower_threshold","title":"<code>ram_lower_threshold</code>  <code>property</code>","text":"<p>Return the RAM lower threshold. If RAM utilization reached this threshold, the microservice will be scaled down (if CPU utilization also reached lower threshold).</p>"},{"location":"api/software_entity/v_microservice/#PyCloudSim.entity.v_microservice.vDefaultMicroservice.ram_upper_threshold","title":"<code>ram_upper_threshold</code>  <code>property</code>","text":"<p>Return the RAM upper threshold. If RAM utilization reached this threshold, the microservice will be scaled up.</p>"},{"location":"api/software_entity/v_microservice/#PyCloudSim.entity.v_microservice.vDefaultMicroservice.__init__","title":"<code>__init__(cpu, ram, image_size, cpu_limit=None, ram_limit=None, volumes=[], priority=0, deamon=False, min_num_instances=1, max_num_instances=3, loadbalancer=Bestfit(), evaluation_interval=0.1, cpu_upper_threshold=0.8, cpu_lower_threshold=0.2, ram_upper_threshold=0.8, ram_lower_threshold=0.2, label=None, create_at=None, terminate_at=None, precursor=None)</code>","text":"<p>Default microservice. It will scale up if CPU or RAM utilization reached upper threshold. It will scale down if CPU and RAM utilization reached lower threshold.</p> Source code in <code>PyCloudSim\\entity\\v_microservice.py</code> <pre><code>def __init__(\n    self,\n    cpu: int | Callable[..., int],\n    ram: int | Callable[..., int],\n    image_size: int | Callable[..., int],\n    cpu_limit: int | Callable[..., int] | None = None,\n    ram_limit: int | Callable[..., int] | None = None,\n    volumes: List[Tuple[int, str, str]] = [],\n    priority: int | Callable[..., int] = 0,\n    deamon: bool | Callable[..., bool] = False,\n    min_num_instances: int | Callable[..., int] = 1,\n    max_num_instances: int | Callable[..., int] = 3,\n    loadbalancer: vLoadbalancer = Bestfit(),\n    evaluation_interval: int\n    | float\n    | Callable[..., int]\n    | Callable[..., float] = 0.1,\n    cpu_upper_threshold: float | Callable[..., float] = 0.8,\n    cpu_lower_threshold: float | Callable[..., float] = 0.2,\n    ram_upper_threshold: float | Callable[..., float] = 0.8,\n    ram_lower_threshold: float | Callable[..., float] = 0.2,\n    label: str | None = None,\n    create_at: int\n    | float\n    | Callable[..., int]\n    | Callable[..., float]\n    | None = None,\n    terminate_at: int\n    | float\n    | Callable[..., int]\n    | Callable[..., float]\n    | None = None,\n    precursor: Entity | List[Entity] | None = None,\n) -&gt; None:\n    \"\"\"Default microservice. It will scale up if CPU or RAM utilization reached upper threshold. It will scale down if CPU and RAM utilization reached lower threshold.\"\"\"\n    super().__init__(\n        cpu,\n        ram,\n        image_size,\n        cpu_limit,\n        ram_limit,\n        volumes,\n        priority,\n        deamon,\n        min_num_instances,\n        max_num_instances,\n        loadbalancer,\n        label,\n        create_at,\n        terminate_at,\n        precursor,\n    )\n\n    if callable(cpu_upper_threshold):\n        self._cpu_upper_threshold = cpu_upper_threshold()\n    else:\n        self._cpu_upper_threshold = cpu_upper_threshold\n\n    if callable(cpu_lower_threshold):\n        self._cpu_lower_threshold = cpu_lower_threshold()\n    else:\n        self._cpu_lower_threshold = cpu_lower_threshold\n\n    if callable(ram_upper_threshold):\n        self._ram_upper_threshold = ram_upper_threshold()\n    else:\n        self._ram_upper_threshold = ram_upper_threshold\n\n    if callable(ram_lower_threshold):\n        self._ram_lower_threshold = ram_lower_threshold()\n    else:\n        self._ram_lower_threshold = ram_lower_threshold\n</code></pre>"},{"location":"api/software_entity/v_microservice/#PyCloudSim.entity.v_microservice.vDefaultMicroservice.horizontal_scale_down_triggered","title":"<code>horizontal_scale_down_triggered()</code>","text":"<p>The microservice will be scaled down if CPU and RAM utilization reached lower threshold.</p> Source code in <code>PyCloudSim\\entity\\v_microservice.py</code> <pre><code>def horizontal_scale_down_triggered(self) -&gt; bool:\n    \"\"\"The microservice will be scaled down if CPU and RAM utilization reached lower threshold.\"\"\"\n    if (\n        self.cpu_utilization &lt;= self.cpu_lower_threshold\n        and self.ram_utilization &lt;= self.ram_lower_threshold\n    ):\n        return True\n    else:\n        return False\n</code></pre>"},{"location":"api/software_entity/v_microservice/#PyCloudSim.entity.v_microservice.vDefaultMicroservice.horizontal_scale_up_triggered","title":"<code>horizontal_scale_up_triggered()</code>","text":"<p>The microservice will be scaled up if CPU or RAM utilization reached upper threshold.</p> Source code in <code>PyCloudSim\\entity\\v_microservice.py</code> <pre><code>def horizontal_scale_up_triggered(self) -&gt; bool:\n    \"\"\"The microservice will be scaled up if CPU or RAM utilization reached upper threshold.\"\"\"\n    if (\n        self.cpu_utilization &gt;= self.cpu_upper_threshold\n        or self.ram_utilization &gt;= self.ram_upper_threshold\n    ):\n        return True\n    else:\n        return False\n</code></pre>"},{"location":"api/software_entity/v_user/","title":"vUser","text":"<p>             Bases: <code>Entity</code></p> Source code in <code>PyCloudSim\\entity\\v_user.py</code> <pre><code>class vUser(Entity):\n    def __init__(\n        self,\n        gateway: vGateway,\n        label: str | None = None,\n        create_at: int\n        | float\n        | Callable[..., int]\n        | Callable[..., float]\n        | None = None,\n        terminate_at: int\n        | float\n        | Callable[..., int]\n        | Callable[..., float]\n        | None = None,\n        precursor: Entity | List[Entity] | None = None,\n    ) -&gt; None:\n        super().__init__(label, create_at, terminate_at, precursor)\n\n        self._host = gateway\n\n    @property\n    def host(self) -&gt; vGateway:\n        return self._host\n</code></pre>"},{"location":"api/software_entity/v_volume/","title":"vVolume","text":"<p>The class \"vVolume\" is implemented to resemble a volume that can be attached to a container in Docker or Kubernetes which consumes the ROM from \"vHost\". A \"vContainer\" could be attached with multiple \"vVolume\" and those  \"vVolume\" could be allocated on different \"vHost\" rather than the \"vHost\" where the \"vContainer\" is hosted.The \"vVolume\" must be allocated first before a \"vContainer\" is scheduled. If any \"vVolume\" is failed to be allocated onto \"vHost\", the schedule of its associated \"vContainer\" will be on hold.</p> <p>             Bases: <code>vSoftwareEntity</code></p> Source code in <code>PyCloudSim\\entity\\v_volume.py</code> <pre><code>class vVolume(vSoftwareEntity):\n    def __init__(\n        self,\n        size: int | Callable[..., Any],\n        path: str | None = None,\n        label: str | None = None,\n        create_at: int\n        | float\n        | Callable[..., int]\n        | Callable[..., float]\n        | None = None,\n        terminate_at: int\n        | float\n        | Callable[..., int]\n        | Callable[..., float]\n        | None = None,\n        precursor: Entity | List[Entity] | None = None,\n    ) -&gt; None:\n        super().__init__(label, create_at, terminate_at, precursor)\n\n        if callable(size):\n            self._store = Resource(MiB(round(size())).bytes)\n        else:\n            self._store = Resource(MiB(size).bytes)\n\n        self._path = path\n\n        self._host: vHost = None  # type: ignore\n\n        simulation.volumes.append(self)\n\n    def on_creation(self):\n        logger.info(f\"{simulation.now}:\\t{self} is created.\")\n\n    def on_termination(self):\n        logger.info(f\"{simulation.now}:\\t{self} is terminated.\")\n\n    @property\n    def size(self) -&gt; int | float:\n        \"\"\"Returns the size of the volume.\"\"\"\n        return self._store.capacity\n\n    @property\n    def path(self) -&gt; str | None:\n        \"\"\"Returns the path of the volume.\"\"\"\n        return self._path\n\n    @property\n    def scheduled(self):\n        \"\"\"Return whether the volume has been scheduled.\"\"\"\n        return Constants.SCHEDULED in self.state\n</code></pre>"},{"location":"api/software_entity/v_volume/#PyCloudSim.entity.v_volume.vVolume.path","title":"<code>path: str | None</code>  <code>property</code>","text":"<p>Returns the path of the volume.</p>"},{"location":"api/software_entity/v_volume/#PyCloudSim.entity.v_volume.vVolume.scheduled","title":"<code>scheduled</code>  <code>property</code>","text":"<p>Return whether the volume has been scheduled.</p>"},{"location":"api/software_entity/v_volume/#PyCloudSim.entity.v_volume.vVolume.size","title":"<code>size: int | float</code>  <code>property</code>","text":"<p>Returns the size of the volume.</p>"},{"location":"api/software_entity/process_packet_apicall/","title":"Index","text":"<p>The \"vProcess\" class represents a simulated computation task similar to a \"Cloudlet\" in CloudSim (Plus). It contains a randomly generated set of instructions, measured in bytes, and the RAM usage is determined by the total length of the instruction set. The \"vCPU\" distributes the \"vProcess\" onto the available \"vCPUCore\" instances, where the instructions of the \"vProcess\" are consumed. Once all instructions have been executed, the \"vProcess\" is considered completed, and a termination process is initiated to release the computational resources. However, the \"vProcess\" may also be terminated abruptly by other events during the simulation. In such cases, if not all instructions have been executed, the \"vProcess\" is considered failed, and the termination process is still triggered.</p> <p>On the other hand, the \"vPacket\" class represents simulated packets for network traffic. Similar to the \"vProcess\", the content of the \"vPacket\" is randomly generated bytes. The \"vPacket\" is transferred between different entities such as \"vSwitch\", \"vRouter\", \"vHost\", and \"vGateway\" using their respective \"vNIC\" instances.</p> <p>The \"vRequest\" class is the implementation of a simulated API call, which creates a sequence of \"vProcess\" and \"vPacket\" instances to simulate the usage of network services. A \"vRequest\" requires a source and a target, which can be a simulated container or a simulated user. If a simulated user is a source or target, the \"vPacket\" will be sent from or received by a \"vGateway\". The type of \"vRequest\" includes GET, POST, DELETE, and LIST, which determine the order and number of \"vProcess\" and \"vPacket\" creations. When a simulated user engages with a simulated Service Function Chain (SFC), a series of requests will be generated and scheduled to interact with the network services. The success of a \"vRequest\" depends on the completion of all associated \"vProcess\" and \"vPacket\" executions or transmissions. If any of them fail, the \"vRequest\" is considered failed and may be retried after a specified delay.</p> <p>The \"vUser\" class represents simulated users who engage with the \"vSFC\" during the simulation. Each user's interaction is modelled as a \"Workflow\" that contains a series of \"vRequest\" instances required to complete a specific \"vSFC\". If any \"vRequest\" fails, the \"Workflow\" is reset, clearing all remaining \"vRequest\" that have not started, and the entire set of \"vRequest\" is recreated to be rescheduled and executed. Simulated users can request to engage with multiple \"vSFC\" instances simultaneously, and each \"Workflow\" is created independently. Users can also request \"vSFC\" in order, where the corresponding \"Workflow\" is executed sequentially. If any \"Workflow\" fails, subsequent \"Workflow\" instances will be terminated immediately.</p> <p>By modelling these classes, the simulation environment can simulate user interactions, the execution of computational tasks, and the transmission of network packets within a simulated cloud environment, allowing for the evaluation of system performance and behaviour.</p>"},{"location":"api/software_entity/process_packet_apicall/v_packet/","title":"vPacket","text":"<p>             Bases: <code>vSoftwareEntity</code></p> Source code in <code>PyCloudSim\\entity\\v_packet.py</code> <pre><code>class vPacket(vSoftwareEntity):\n    def __init__(\n        self,\n        src: vContainer | vUser,\n        dst: vContainer | vUser,\n        size: int | Callable[..., int],\n        priority: int | Callable[..., int],\n        label: str | None = None,\n        create_at: int\n        | float\n        | Callable[..., int]\n        | Callable[..., float]\n        | None = None,\n        terminate_at: int\n        | float\n        | Callable[..., int]\n        | Callable[..., float]\n        | None = None,\n        precursor: Entity | List[Entity] | None = None,\n    ) -&gt; None:\n        \"\"\"Create a simulated packet.\"\"\"\n        super().__init__(label, create_at, terminate_at, precursor)\n        self._src = src\n        self._src_host = src.host\n        self._dst = dst\n        self._dst_host = dst.host\n        if callable(size):\n            self._size = size()\n        else:\n            self._size = size\n        if callable(priority):\n            self._priority = priority()\n        else:\n            self._priority = priority\n        self._content = bytes()\n        self._path: List[vHardwareEntity | vGateway] = []\n        self._current_hop: vHardwareEntity | vGateway = None  # type: ignore\n        self._next_hop: vHardwareEntity | vGateway = None  # type: ignore\n\n    def on_creation(self):\n        \"\"\"Creation procedure of the simulated packet.\"\"\"\n        super().on_creation()\n        logger.info(f\"{simulation.now}:\\t{self} is created.\")\n        self.initiate(simulation.now)\n\n    def on_initiate(self) -&gt; None:\n        \"\"\"The initiation procedure of the simulated packet.\"\"\"\n        super().on_initiate()\n        # generate the random bytes content\n        self._content = randbytes(self.size)\n        # find the shortest path from src to dst\n        self._path = simulation.network.route(self.src_host, self.dst_host)  # type: ignore\n        if len(self.path) == 1:\n            self._path = [self.path[0], self.path[0]]\n        self._current_hop = self.path[0]\n        self._next_hop = self.path[1]\n        # inject the packet to its src\n        try:\n            self.get(self.src_host.ram, self.size)\n        except:\n            # drop the packet if its src does not have enough ram\n            self.drop()\n            return\n        self.state.append(Constants.DECODED)\n        self.src_host.packet_queue.append(self)\n        logger.info(f\"{simulation.now}:\\t{self} is initiated.\")\n\n    def on_termination(self):\n        \"\"\"Termination procedure of the simulated packet.\"\"\"\n        super().on_termination()\n        logger.info(f\"{simulation.now}:\\tPacket {self.label} is terminated.\")\n\n    def on_fail(self):\n        \"\"\"Failure procedure of the simulated packet.\"\"\"\n        super().on_fail()\n        logger.info(f\"{simulation.now}:\\tPacket {self.label} is dropped.\")\n\n    def drop(self):\n        \"\"\"Drop the simulated packet which calls the fail procedure.\"\"\"\n        self.fail(simulation.now)\n\n    @property\n    def src(self):\n        \"\"\"return the source of the packet, could be a simulated user or container.\"\"\"\n        return self._src\n\n    @property\n    def src_host(self):\n        \"\"\"return the source host of the packet, could be a simulated host or gateway.\"\"\"\n        return self._src_host\n\n    @property\n    def dst(self):\n        \"\"\"return the destination of the packet, could be a simulated user or container.\"\"\"\n        return self._dst\n\n    @property\n    def dst_host(self):\n        \"\"\"return the destination host of the packet, could be a simulated host or gateway.\"\"\"\n        return self._dst_host\n\n    @property\n    def path(self):\n        \"\"\"return the path of the packet.\"\"\"\n        return self._path\n\n    @property\n    def size(self) -&gt; int:\n        \"\"\"return the size of the packet.\"\"\"\n        return self._size\n\n    @property\n    def content(self) -&gt; bytes:\n        \"\"\"return the content of the packet.\"\"\"\n        return self._content\n\n    @property\n    def priority(self) -&gt; int:\n        \"\"\"return the priority of the packet.\"\"\"\n        return self._priority\n\n    @property\n    def current_hop(self):\n        \"\"\"return the current hop of the packet.\"\"\"\n        return self._current_hop\n\n    @property\n    def next_hop(self):\n        \"\"\"return the next hop of the packet.\"\"\"\n        return self._next_hop\n\n    @property\n    def decoded(self) -&gt; bool:\n        \"\"\"return True if the packet is decoded. This happens after the asscoiated decoder process is executed.\"\"\"\n        return Constants.DECODED in self.state\n\n    @property\n    def in_transmission(self) -&gt; bool:\n        \"\"\"return True if the packet is in transmission.\"\"\"\n        return Constants.INTRANSMISSION in self.state\n</code></pre>"},{"location":"api/software_entity/process_packet_apicall/v_packet/#PyCloudSim.entity.v_packet.vPacket.content","title":"<code>content: bytes</code>  <code>property</code>","text":"<p>return the content of the packet.</p>"},{"location":"api/software_entity/process_packet_apicall/v_packet/#PyCloudSim.entity.v_packet.vPacket.current_hop","title":"<code>current_hop</code>  <code>property</code>","text":"<p>return the current hop of the packet.</p>"},{"location":"api/software_entity/process_packet_apicall/v_packet/#PyCloudSim.entity.v_packet.vPacket.decoded","title":"<code>decoded: bool</code>  <code>property</code>","text":"<p>return True if the packet is decoded. This happens after the asscoiated decoder process is executed.</p>"},{"location":"api/software_entity/process_packet_apicall/v_packet/#PyCloudSim.entity.v_packet.vPacket.dst","title":"<code>dst</code>  <code>property</code>","text":"<p>return the destination of the packet, could be a simulated user or container.</p>"},{"location":"api/software_entity/process_packet_apicall/v_packet/#PyCloudSim.entity.v_packet.vPacket.dst_host","title":"<code>dst_host</code>  <code>property</code>","text":"<p>return the destination host of the packet, could be a simulated host or gateway.</p>"},{"location":"api/software_entity/process_packet_apicall/v_packet/#PyCloudSim.entity.v_packet.vPacket.in_transmission","title":"<code>in_transmission: bool</code>  <code>property</code>","text":"<p>return True if the packet is in transmission.</p>"},{"location":"api/software_entity/process_packet_apicall/v_packet/#PyCloudSim.entity.v_packet.vPacket.next_hop","title":"<code>next_hop</code>  <code>property</code>","text":"<p>return the next hop of the packet.</p>"},{"location":"api/software_entity/process_packet_apicall/v_packet/#PyCloudSim.entity.v_packet.vPacket.path","title":"<code>path</code>  <code>property</code>","text":"<p>return the path of the packet.</p>"},{"location":"api/software_entity/process_packet_apicall/v_packet/#PyCloudSim.entity.v_packet.vPacket.priority","title":"<code>priority: int</code>  <code>property</code>","text":"<p>return the priority of the packet.</p>"},{"location":"api/software_entity/process_packet_apicall/v_packet/#PyCloudSim.entity.v_packet.vPacket.size","title":"<code>size: int</code>  <code>property</code>","text":"<p>return the size of the packet.</p>"},{"location":"api/software_entity/process_packet_apicall/v_packet/#PyCloudSim.entity.v_packet.vPacket.src","title":"<code>src</code>  <code>property</code>","text":"<p>return the source of the packet, could be a simulated user or container.</p>"},{"location":"api/software_entity/process_packet_apicall/v_packet/#PyCloudSim.entity.v_packet.vPacket.src_host","title":"<code>src_host</code>  <code>property</code>","text":"<p>return the source host of the packet, could be a simulated host or gateway.</p>"},{"location":"api/software_entity/process_packet_apicall/v_packet/#PyCloudSim.entity.v_packet.vPacket.__init__","title":"<code>__init__(src, dst, size, priority, label=None, create_at=None, terminate_at=None, precursor=None)</code>","text":"<p>Create a simulated packet.</p> Source code in <code>PyCloudSim\\entity\\v_packet.py</code> <pre><code>def __init__(\n    self,\n    src: vContainer | vUser,\n    dst: vContainer | vUser,\n    size: int | Callable[..., int],\n    priority: int | Callable[..., int],\n    label: str | None = None,\n    create_at: int\n    | float\n    | Callable[..., int]\n    | Callable[..., float]\n    | None = None,\n    terminate_at: int\n    | float\n    | Callable[..., int]\n    | Callable[..., float]\n    | None = None,\n    precursor: Entity | List[Entity] | None = None,\n) -&gt; None:\n    \"\"\"Create a simulated packet.\"\"\"\n    super().__init__(label, create_at, terminate_at, precursor)\n    self._src = src\n    self._src_host = src.host\n    self._dst = dst\n    self._dst_host = dst.host\n    if callable(size):\n        self._size = size()\n    else:\n        self._size = size\n    if callable(priority):\n        self._priority = priority()\n    else:\n        self._priority = priority\n    self._content = bytes()\n    self._path: List[vHardwareEntity | vGateway] = []\n    self._current_hop: vHardwareEntity | vGateway = None  # type: ignore\n    self._next_hop: vHardwareEntity | vGateway = None  # type: ignore\n</code></pre>"},{"location":"api/software_entity/process_packet_apicall/v_packet/#PyCloudSim.entity.v_packet.vPacket.drop","title":"<code>drop()</code>","text":"<p>Drop the simulated packet which calls the fail procedure.</p> Source code in <code>PyCloudSim\\entity\\v_packet.py</code> <pre><code>def drop(self):\n    \"\"\"Drop the simulated packet which calls the fail procedure.\"\"\"\n    self.fail(simulation.now)\n</code></pre>"},{"location":"api/software_entity/process_packet_apicall/v_packet/#PyCloudSim.entity.v_packet.vPacket.on_creation","title":"<code>on_creation()</code>","text":"<p>Creation procedure of the simulated packet.</p> Source code in <code>PyCloudSim\\entity\\v_packet.py</code> <pre><code>def on_creation(self):\n    \"\"\"Creation procedure of the simulated packet.\"\"\"\n    super().on_creation()\n    logger.info(f\"{simulation.now}:\\t{self} is created.\")\n    self.initiate(simulation.now)\n</code></pre>"},{"location":"api/software_entity/process_packet_apicall/v_packet/#PyCloudSim.entity.v_packet.vPacket.on_fail","title":"<code>on_fail()</code>","text":"<p>Failure procedure of the simulated packet.</p> Source code in <code>PyCloudSim\\entity\\v_packet.py</code> <pre><code>def on_fail(self):\n    \"\"\"Failure procedure of the simulated packet.\"\"\"\n    super().on_fail()\n    logger.info(f\"{simulation.now}:\\tPacket {self.label} is dropped.\")\n</code></pre>"},{"location":"api/software_entity/process_packet_apicall/v_packet/#PyCloudSim.entity.v_packet.vPacket.on_initiate","title":"<code>on_initiate()</code>","text":"<p>The initiation procedure of the simulated packet.</p> Source code in <code>PyCloudSim\\entity\\v_packet.py</code> <pre><code>def on_initiate(self) -&gt; None:\n    \"\"\"The initiation procedure of the simulated packet.\"\"\"\n    super().on_initiate()\n    # generate the random bytes content\n    self._content = randbytes(self.size)\n    # find the shortest path from src to dst\n    self._path = simulation.network.route(self.src_host, self.dst_host)  # type: ignore\n    if len(self.path) == 1:\n        self._path = [self.path[0], self.path[0]]\n    self._current_hop = self.path[0]\n    self._next_hop = self.path[1]\n    # inject the packet to its src\n    try:\n        self.get(self.src_host.ram, self.size)\n    except:\n        # drop the packet if its src does not have enough ram\n        self.drop()\n        return\n    self.state.append(Constants.DECODED)\n    self.src_host.packet_queue.append(self)\n    logger.info(f\"{simulation.now}:\\t{self} is initiated.\")\n</code></pre>"},{"location":"api/software_entity/process_packet_apicall/v_packet/#PyCloudSim.entity.v_packet.vPacket.on_termination","title":"<code>on_termination()</code>","text":"<p>Termination procedure of the simulated packet.</p> Source code in <code>PyCloudSim\\entity\\v_packet.py</code> <pre><code>def on_termination(self):\n    \"\"\"Termination procedure of the simulated packet.\"\"\"\n    super().on_termination()\n    logger.info(f\"{simulation.now}:\\tPacket {self.label} is terminated.\")\n</code></pre>"},{"location":"api/software_entity/process_packet_apicall/v_process/","title":"vInstruction","text":"<p>             Bases: <code>Entity</code></p> <p>Base for simulated instructions.</p> Source code in <code>PyCloudSim\\entity\\v_instruction.py</code> <pre><code>class vInstruction(Entity):\n    \"\"\"Base for simulated instructions.\"\"\"\n\n    def __init__(\n        self,\n        process: vProcess | vContainerProcess | vDeamon | vDecoder,\n        create_at: int | float | Callable[..., int] | Callable[..., float] | None,\n    ) -&gt; None:\n        \"\"\"Create a simulated instruction. It will be consumed by the simulated CPU core. Once all simulated instruction of a process is consumed, the process is considered to be successfully executed.\"\"\"\n        super().__init__(f\"{process.label}-{len(process.instructions)}\", create_at)\n        self._process = process\n        self._instruction = bytes()\n\n    def __str__(self) -&gt; str:\n        return f\"{self.__class__.__name__}-{self.label}\"\n\n    def on_creation(self):\n        \"\"\"Populate the instruction with random bytes to simulate RAM usage.\"\"\"\n        if self.process.host is None:\n            raise RuntimeError(f\"{self} is not associated a host\")\n\n        if self.process.host.architecture == Constants.X86:\n            self._instruction = randbytes(randint(1, 16))\n        elif self.process.host.architecture == Constants.ARM:\n            self._instruction = randbytes(4)\n        else:\n            raise RuntimeError(f\"{self.process.host} has an unknown architecture\")\n        self.process.instructions.append(self)\n        self.process.unscheduled_instructions.append(self)\n\n    def on_termination(self):\n        \"\"\"Terminate the simulated instruction. Called when the instruction is consumed by the CPU core.\"\"\"\n        # clear out the resource usage\n        if self.process.container is not None:\n            if self.process.container.host is not None:\n                self.process.container._cpu_usage -= (1 * 1000) / (\n                    self.process.container.host.cpu.ipc\n                    * self.process.container.host.cpu.frequency\n                )\n                self.process.container._ram_usage -= self.length\n\n    @property\n    def process(self):\n        \"\"\"Return the process that this instruction belongs to.\"\"\"\n        return self._process\n\n    @property\n    def instruction(self) -&gt; bytes:\n        \"\"\"The instruction\"\"\"\n        return self._instruction\n\n    @property\n    def length(self) -&gt; int:\n        \"\"\"The length of the instruction\"\"\"\n        return len(self.instruction) * 100000\n</code></pre>"},{"location":"api/software_entity/process_packet_apicall/v_process/#PyCloudSim.entity.v_instruction.vInstruction.instruction","title":"<code>instruction: bytes</code>  <code>property</code>","text":"<p>The instruction</p>"},{"location":"api/software_entity/process_packet_apicall/v_process/#PyCloudSim.entity.v_instruction.vInstruction.length","title":"<code>length: int</code>  <code>property</code>","text":"<p>The length of the instruction</p>"},{"location":"api/software_entity/process_packet_apicall/v_process/#PyCloudSim.entity.v_instruction.vInstruction.process","title":"<code>process</code>  <code>property</code>","text":"<p>Return the process that this instruction belongs to.</p>"},{"location":"api/software_entity/process_packet_apicall/v_process/#PyCloudSim.entity.v_instruction.vInstruction.__init__","title":"<code>__init__(process, create_at)</code>","text":"<p>Create a simulated instruction. It will be consumed by the simulated CPU core. Once all simulated instruction of a process is consumed, the process is considered to be successfully executed.</p> Source code in <code>PyCloudSim\\entity\\v_instruction.py</code> <pre><code>def __init__(\n    self,\n    process: vProcess | vContainerProcess | vDeamon | vDecoder,\n    create_at: int | float | Callable[..., int] | Callable[..., float] | None,\n) -&gt; None:\n    \"\"\"Create a simulated instruction. It will be consumed by the simulated CPU core. Once all simulated instruction of a process is consumed, the process is considered to be successfully executed.\"\"\"\n    super().__init__(f\"{process.label}-{len(process.instructions)}\", create_at)\n    self._process = process\n    self._instruction = bytes()\n</code></pre>"},{"location":"api/software_entity/process_packet_apicall/v_process/#PyCloudSim.entity.v_instruction.vInstruction.on_creation","title":"<code>on_creation()</code>","text":"<p>Populate the instruction with random bytes to simulate RAM usage.</p> Source code in <code>PyCloudSim\\entity\\v_instruction.py</code> <pre><code>def on_creation(self):\n    \"\"\"Populate the instruction with random bytes to simulate RAM usage.\"\"\"\n    if self.process.host is None:\n        raise RuntimeError(f\"{self} is not associated a host\")\n\n    if self.process.host.architecture == Constants.X86:\n        self._instruction = randbytes(randint(1, 16))\n    elif self.process.host.architecture == Constants.ARM:\n        self._instruction = randbytes(4)\n    else:\n        raise RuntimeError(f\"{self.process.host} has an unknown architecture\")\n    self.process.instructions.append(self)\n    self.process.unscheduled_instructions.append(self)\n</code></pre>"},{"location":"api/software_entity/process_packet_apicall/v_process/#PyCloudSim.entity.v_instruction.vInstruction.on_termination","title":"<code>on_termination()</code>","text":"<p>Terminate the simulated instruction. Called when the instruction is consumed by the CPU core.</p> Source code in <code>PyCloudSim\\entity\\v_instruction.py</code> <pre><code>def on_termination(self):\n    \"\"\"Terminate the simulated instruction. Called when the instruction is consumed by the CPU core.\"\"\"\n    # clear out the resource usage\n    if self.process.container is not None:\n        if self.process.container.host is not None:\n            self.process.container._cpu_usage -= (1 * 1000) / (\n                self.process.container.host.cpu.ipc\n                * self.process.container.host.cpu.frequency\n            )\n            self.process.container._ram_usage -= self.length\n</code></pre>"},{"location":"api/software_entity/process_packet_apicall/v_process/#vcontainerprocess","title":"vContainerProcess","text":"<p>             Bases: <code>vProcess</code></p> Source code in <code>PyCloudSim\\entity\\v_process.py</code> <pre><code>class vContainerProcess(vProcess):\n    def __init__(\n        self,\n        container: vContainer,\n        length: int | Callable[..., int],\n        priority: int | Callable[..., int] = 0,\n        label: str | None = None,\n        create_at: int\n        | float\n        | Callable[..., int]\n        | Callable[..., float]\n        | None = None,\n        terminate_at: int\n        | float\n        | Callable[..., int]\n        | Callable[..., float]\n        | None = None,\n        precursor: Entity | List[Entity] | None = None,\n    ) -&gt; None:\n        \"\"\"Create a simulated process that runs in a container.\"\"\"\n        super().__init__(length, priority, label, create_at, terminate_at, precursor)\n        self._container = container\n\n    def on_initiate(self):\n        \"\"\"The initiation procedure of the simulated process.\"\"\"\n        super().on_initiate()\n        if self.container is None:\n            raise ValueError(f\"{self} is not assigned to a container.\")\n\n        self.container.process_queue.append(self)\n        self.container.host.cpu.process_queue.append(self)\n\n    @property\n    def container(self):\n        \"\"\"The container that executes this process\"\"\"\n        return self._container\n\n    @property\n    def host(self):\n        \"\"\"The host that executes this process\"\"\"\n        return self.container.host\n</code></pre>"},{"location":"api/software_entity/process_packet_apicall/v_process/#PyCloudSim.entity.v_process.vContainerProcess.container","title":"<code>container</code>  <code>property</code>","text":"<p>The container that executes this process</p>"},{"location":"api/software_entity/process_packet_apicall/v_process/#PyCloudSim.entity.v_process.vContainerProcess.host","title":"<code>host</code>  <code>property</code>","text":"<p>The host that executes this process</p>"},{"location":"api/software_entity/process_packet_apicall/v_process/#PyCloudSim.entity.v_process.vContainerProcess.__init__","title":"<code>__init__(container, length, priority=0, label=None, create_at=None, terminate_at=None, precursor=None)</code>","text":"<p>Create a simulated process that runs in a container.</p> Source code in <code>PyCloudSim\\entity\\v_process.py</code> <pre><code>def __init__(\n    self,\n    container: vContainer,\n    length: int | Callable[..., int],\n    priority: int | Callable[..., int] = 0,\n    label: str | None = None,\n    create_at: int\n    | float\n    | Callable[..., int]\n    | Callable[..., float]\n    | None = None,\n    terminate_at: int\n    | float\n    | Callable[..., int]\n    | Callable[..., float]\n    | None = None,\n    precursor: Entity | List[Entity] | None = None,\n) -&gt; None:\n    \"\"\"Create a simulated process that runs in a container.\"\"\"\n    super().__init__(length, priority, label, create_at, terminate_at, precursor)\n    self._container = container\n</code></pre>"},{"location":"api/software_entity/process_packet_apicall/v_process/#PyCloudSim.entity.v_process.vContainerProcess.on_initiate","title":"<code>on_initiate()</code>","text":"<p>The initiation procedure of the simulated process.</p> Source code in <code>PyCloudSim\\entity\\v_process.py</code> <pre><code>def on_initiate(self):\n    \"\"\"The initiation procedure of the simulated process.\"\"\"\n    super().on_initiate()\n    if self.container is None:\n        raise ValueError(f\"{self} is not assigned to a container.\")\n\n    self.container.process_queue.append(self)\n    self.container.host.cpu.process_queue.append(self)\n</code></pre>"},{"location":"api/software_entity/process_packet_apicall/v_process/#vdeamon","title":"vDeamon","text":"<p>             Bases: <code>vProcess</code></p> Source code in <code>PyCloudSim\\entity\\v_process.py</code> <pre><code>class vDeamon(vProcess):\n    def __init__(\n        self,\n        container: vContainer,\n        length: int | Callable[..., int],\n        priority: int | Callable[..., int] = 0,\n        label: str | None = None,\n        create_at: int\n        | float\n        | Callable[..., int]\n        | Callable[..., float]\n        | None = None,\n        terminate_at: int\n        | float\n        | Callable[..., int]\n        | Callable[..., float]\n        | None = None,\n        precursor: Entity | List[Entity] | None = None,\n    ) -&gt; None:\n        \"\"\"Create a simulated deamon that belongs to a container.\"\"\"\n        super().__init__(length, priority, label, create_at, terminate_at, precursor)\n        self._container = container\n\n    def on_initiate(self):\n        super().on_initiate()\n        if self.container is None:\n            raise ValueError(f\"{self} is not assigned to a container.\")\n\n        self.container.process_queue.append(self)\n        self.container.host.cpu.process_queue.append(self)\n\n    def on_fail(self) -&gt; None:\n        super().on_fail()\n        self.container.fail(simulation.now)\n\n    @property\n    def container(self):\n        \"\"\"The container that executes this process\"\"\"\n        return self._container\n\n    @property\n    def host(self):\n        \"\"\"The host that executes this process\"\"\"\n        return self.container.host\n\n    @property\n    def deamon(self):\n        return True\n</code></pre>"},{"location":"api/software_entity/process_packet_apicall/v_process/#PyCloudSim.entity.v_process.vDeamon.container","title":"<code>container</code>  <code>property</code>","text":"<p>The container that executes this process</p>"},{"location":"api/software_entity/process_packet_apicall/v_process/#PyCloudSim.entity.v_process.vDeamon.host","title":"<code>host</code>  <code>property</code>","text":"<p>The host that executes this process</p>"},{"location":"api/software_entity/process_packet_apicall/v_process/#PyCloudSim.entity.v_process.vDeamon.__init__","title":"<code>__init__(container, length, priority=0, label=None, create_at=None, terminate_at=None, precursor=None)</code>","text":"<p>Create a simulated deamon that belongs to a container.</p> Source code in <code>PyCloudSim\\entity\\v_process.py</code> <pre><code>def __init__(\n    self,\n    container: vContainer,\n    length: int | Callable[..., int],\n    priority: int | Callable[..., int] = 0,\n    label: str | None = None,\n    create_at: int\n    | float\n    | Callable[..., int]\n    | Callable[..., float]\n    | None = None,\n    terminate_at: int\n    | float\n    | Callable[..., int]\n    | Callable[..., float]\n    | None = None,\n    precursor: Entity | List[Entity] | None = None,\n) -&gt; None:\n    \"\"\"Create a simulated deamon that belongs to a container.\"\"\"\n    super().__init__(length, priority, label, create_at, terminate_at, precursor)\n    self._container = container\n</code></pre>"},{"location":"api/software_entity/process_packet_apicall/v_process/#vdecoder","title":"vDecoder","text":"<p>             Bases: <code>vProcess</code></p> Source code in <code>PyCloudSim\\entity\\v_process.py</code> <pre><code>class vDecoder(vProcess):\n    def __init__(\n        self,\n        packet: vPacket,\n        host: vHardwareEntity,\n        length: int | Callable[..., int],\n        priority: int | Callable[..., int] = 0,\n        label: str | None = None,\n        create_at: int\n        | float\n        | Callable[..., int]\n        | Callable[..., float]\n        | None = None,\n        terminate_at: int\n        | float\n        | Callable[..., int]\n        | Callable[..., float]\n        | None = None,\n        precursor: Entity | List[Entity] | None = None,\n    ) -&gt; None:\n        \"\"\"Create a simulated decoder that decodes a packet. It will be automatically created when a packet is received by a host.\"\"\"\n        super().__init__(length, priority, label, create_at, terminate_at, precursor)\n        self._packet = packet\n        self._host = host\n\n    def on_initiate(self):\n        \"\"\"The initiation procedure of the simulated decoder.\"\"\"\n        super().on_initiate()\n        if self.host is None:\n            raise ValueError(f\"{self} is not assigned to a host.\")\n        self.host.process_queue.append(self)\n\n    def on_success(self):\n        super().on_success()\n        self.packet.state.append(Constants.DECODED)\n        logger.info(f\"{simulation.now}:\\t{self.packet} is decoded.\")\n        if self.packet.current_hop is self.packet.dst_host:\n            self.packet.success(simulation.now)\n\n    def on_fail(self) -&gt; None:\n        super().on_fail()\n        self.packet.fail(simulation.now)\n\n    @property\n    def packet(self):\n        \"\"\"The packet that is decoded\"\"\"\n        return self._packet\n\n    @property\n    def host(self):\n        \"\"\"The host that decodes the packet\"\"\"\n        return self._host\n</code></pre>"},{"location":"api/software_entity/process_packet_apicall/v_process/#PyCloudSim.entity.v_process.vDecoder.host","title":"<code>host</code>  <code>property</code>","text":"<p>The host that decodes the packet</p>"},{"location":"api/software_entity/process_packet_apicall/v_process/#PyCloudSim.entity.v_process.vDecoder.packet","title":"<code>packet</code>  <code>property</code>","text":"<p>The packet that is decoded</p>"},{"location":"api/software_entity/process_packet_apicall/v_process/#PyCloudSim.entity.v_process.vDecoder.__init__","title":"<code>__init__(packet, host, length, priority=0, label=None, create_at=None, terminate_at=None, precursor=None)</code>","text":"<p>Create a simulated decoder that decodes a packet. It will be automatically created when a packet is received by a host.</p> Source code in <code>PyCloudSim\\entity\\v_process.py</code> <pre><code>def __init__(\n    self,\n    packet: vPacket,\n    host: vHardwareEntity,\n    length: int | Callable[..., int],\n    priority: int | Callable[..., int] = 0,\n    label: str | None = None,\n    create_at: int\n    | float\n    | Callable[..., int]\n    | Callable[..., float]\n    | None = None,\n    terminate_at: int\n    | float\n    | Callable[..., int]\n    | Callable[..., float]\n    | None = None,\n    precursor: Entity | List[Entity] | None = None,\n) -&gt; None:\n    \"\"\"Create a simulated decoder that decodes a packet. It will be automatically created when a packet is received by a host.\"\"\"\n    super().__init__(length, priority, label, create_at, terminate_at, precursor)\n    self._packet = packet\n    self._host = host\n</code></pre>"},{"location":"api/software_entity/process_packet_apicall/v_process/#PyCloudSim.entity.v_process.vDecoder.on_initiate","title":"<code>on_initiate()</code>","text":"<p>The initiation procedure of the simulated decoder.</p> Source code in <code>PyCloudSim\\entity\\v_process.py</code> <pre><code>def on_initiate(self):\n    \"\"\"The initiation procedure of the simulated decoder.\"\"\"\n    super().on_initiate()\n    if self.host is None:\n        raise ValueError(f\"{self} is not assigned to a host.\")\n    self.host.process_queue.append(self)\n</code></pre>"},{"location":"api/software_entity/process_packet_apicall/vapicall/","title":"vAPICall","text":"<p>             Bases: <code>vSoftwareEntity</code></p> <p>A vAPICall is a software entity that represents an API call.</p> Source code in <code>PyCloudSim\\entity\\v_apicall.py</code> <pre><code>class vAPICall(vSoftwareEntity):\n    \"\"\"A vAPICall is a software entity that represents an API call.\"\"\"\n\n    def __init__(\n        self,\n        src: vMicroservice | vUser,\n        dst: vMicroservice | vUser,\n        priority: int | Callable[..., int],\n        src_process_length: int | Callable[..., int],\n        dst_process_length: int | Callable[..., int],\n        ack_process_length: int | Callable[..., int],\n        num_src_packets: int | Callable[..., int],\n        src_packet_size: int | Callable[..., int],\n        num_ret_packets: int | Callable[..., int],\n        ret_packet_size: int | Callable[..., int],\n        num_ack_packets: int | Callable[..., int],\n        ack_packet_size: int | Callable[..., int],\n        label: str | None = None,\n        create_at: int\n        | float\n        | Callable[..., int]\n        | Callable[..., float]\n        | None = None,\n        terminate_at: int\n        | float\n        | Callable[..., int]\n        | Callable[..., float]\n        | None = None,\n        precursor: Entity | List[Entity] | None = None,\n    ) -&gt; None:\n        \"\"\"Create a new vAPICall.\n\n        Args:\n            src (vMicroservice | vUser): the source of the API call.\n            dst (vMicroservice | vUser): the destination of the API call.\n            priority (int | Callable[..., int]): the priority of the API call.\n            src_process_length (int | Callable[..., int]): the length of the source process.\n            dst_process_length (int | Callable[..., int]): the length of the destination process.\n            ack_process_length (int | Callable[..., int]): the length of the ack process.\n            num_src_packets (int | Callable[..., int]): the number of packets from source.\n            src_packet_size (int | Callable[..., int]): the size of the packets from source.\n            num_ret_packets (int | Callable[..., int]): the number of packets returned from destination.\n            ret_packet_size (int | Callable[..., int]): the size of the packets returned from destination.\n            num_ack_packets (int | Callable[..., int]): the number of packets from source for ACK.\n            ack_packet_size (int | Callable[..., int]): the size of the packets from source for ACK.\n            label (str | None, optional): short description of this vAPICall. Defaults to None.\n            create_at (int | float | Callable[..., int] | Callable[..., float] | None, optional): when this vAPICall should be created. Defaults to None.\n            terminate_at (int | float | Callable[..., int] | Callable[..., float] | None, optional): when this vAPICall shoudl be terminated. Defaults to None.\n            precursor (Entity | List[Entity] | None, optional): the precursor of this vAPICall. Defaults to None.\n        \"\"\"\n        super().__init__(label, create_at, terminate_at, precursor)\n        self._src = src\n        self._dst = dst\n        self._type = type\n        if callable(priority):\n            self._priority = round(priority())\n        else:\n            self._priority = priority\n        if callable(src_process_length):\n            self._src_process_length = round(src_process_length())\n        else:\n            self._src_process_length = src_process_length\n        if callable(dst_process_length):\n            self._dst_process_length = round(dst_process_length())\n        else:\n            self._dst_process_length = dst_process_length\n        if callable(ack_process_length):\n            self._ack_process_length = round(ack_process_length())\n        else:\n            self._ack_process_length = ack_process_length\n        if callable(num_src_packets):\n            self._num_src_packets = round(num_src_packets())\n        else:\n            self._num_src_packets = num_src_packets\n        if callable(src_packet_size):\n            self._src_packet_size = round(src_packet_size())\n        else:\n            self._src_packet_size = src_packet_size\n        if callable(num_ret_packets):\n            self._num_ret_packets = round(num_ret_packets())\n        else:\n            self._num_ret_packets = num_ret_packets\n        if callable(ret_packet_size):\n            self._ret_packet_size = round(ret_packet_size())\n        else:\n            self._ret_packet_size = ret_packet_size\n        if callable(num_ack_packets):\n            self._num_ack_packets = round(num_ack_packets())\n        else:\n            self._num_ack_packets = num_ack_packets\n        if callable(ack_packet_size):\n            self._ack_packet_size = round(ack_packet_size())\n        else:\n            self._ack_packet_size = ack_packet_size\n\n        self._packets: List[vPacket] = [] # EntityList(label=f\"{self} Packets\")\n        self._processes: List[vContainerProcess] = [] # EntityList(label=f\"{self} Processes\")\n        simulation.api_calls.append(self)\n\n    def on_creation(self):\n        super().on_creation()\n\n    def on_initiate(self) -&gt; None:\n        \"\"\"Initiate the vAPICall.\n        \"\"\"\n        super().on_initiate()\n        if isinstance(self.src, vUser) and isinstance(self.dst, vUser):\n            if self.src_process_length &gt; 0:\n                logger.warning(\n                    f\"{simulation.now}:\\t{self} source is a vUser, src_instruction_length is ignored.\"\n                )\n            if self.dst_process_length &gt; 0:\n                logger.warning(\n                    f\"{simulation.now}:\\t{self} destination is a vUser, dst_instruction_length is ignored.\"\n                )\n            if self.ack_process_length &gt; 0:\n                logger.warning(\n                    f\"{simulation.now}:\\t{self} source is a vUser, ack_instruction_length is ignored.\"\n                )\n\n            if self.num_src_packets &lt;= 0:\n                logger.error(\n                    f\"{simulation.now}:\\t{self} invalid vAPICall configuration.\"\n                )\n                self.terminate(simulation.now)\n                return\n\n            src_packets: List[Entity] = list()\n            for i in range(self.num_src_packets):\n                src_packet = vPacket(\n                    src=self.src,\n                    dst=self.dst,\n                    size=self.src_packet_size,\n                    priority=self.priority,\n                    create_at=simulation.now,\n                    label=f\"{self}-SRC-{i}\",\n                )\n                self.packets.append(src_packet)\n                src_packets.append(src_packet)\n\n            ret_packets: List[Entity] = list()\n            for i in range(self.num_ret_packets):\n                ret_packet = vPacket(\n                    src=self.dst,\n                    dst=self.src,\n                    size=self.ret_packet_size,\n                    priority=self.priority,\n                    create_at=simulation.now,\n                    label=f\"{self}-RET-{i}\",\n                    precursor=src_packets,\n                )\n                self.packets.append(ret_packet)\n                ret_packets.append(ret_packet)\n\n            ack_packets: List[Entity] = list()\n            for i in range(self.num_ack_packets):\n                ack_packet = vPacket(\n                    src=self.src,\n                    dst=self.dst,\n                    size=self.ack_packet_size,\n                    priority=self.priority,\n                    create_at=simulation.now,\n                    label=f\"{self}-ACK-{i}\",\n                    precursor=ret_packets,\n                )\n                self.packets.append(ack_packet)\n                ack_packets.append(ack_packet)\n\n        elif isinstance(self.src, vUser) and not isinstance(self.dst, vUser):\n            if self.src_process_length &gt; 0:\n                logger.warning(\n                    f\"{simulation.now}:\\t{self} source is a vUser, src_instruction_length is ignored.\"\n                )\n            if self.ack_process_length &gt; 0:\n                logger.warning(\n                    f\"{simulation.now}:\\t{self} source is a vUser, ack_instruction_length is ignored.\"\n                )\n\n            if self.num_src_packets &lt;= 0:\n                logger.error(\n                    f\"{simulation.now}:\\t{self} invalid vAPICall configuration.\"\n                )\n                self.terminate(simulation.now)\n                return\n\n            dst_container = self.dst.getContainer()\n\n            src_packets: List[Entity] = list()\n            for i in range(self.num_src_packets):\n                src_packet = vPacket(\n                    src=self.src,\n                    dst=dst_container,\n                    size=self.src_packet_size,\n                    priority=self.priority,\n                    create_at=simulation.now,\n                    label=f\"{self}-SRC-{i}\",\n                )\n                self.packets.append(src_packet)\n                src_packets.append(src_packet)\n\n            dst_process = vContainerProcess(\n                container=self.dst.getContainer(),\n                length=self.dst_process_length,\n                priority=self.priority,\n                precursor=src_packets,\n                create_at=simulation.now,\n                label=f\"{self}-DST\",\n            )\n\n            ret_packets: List[Entity] = list()\n            for i in range(self.num_ret_packets):\n                ret_packet = vPacket(\n                    src=dst_container,\n                    dst=self.src,\n                    size=self.ret_packet_size,\n                    priority=self.priority,\n                    create_at=simulation.now,\n                    label=f\"{self}-RET-{i}\",\n                    precursor=dst_process,\n                )\n                self.packets.append(ret_packet)\n                ret_packets.append(ret_packet)\n\n            for i in range(self.num_ack_packets):\n                ack_packet = vPacket(\n                    src=self.src,\n                    dst=dst_container,\n                    size=self.ack_packet_size,\n                    priority=self.priority,\n                    create_at=simulation.now,\n                    label=f\"{self}-ACK-{i}\",\n                    precursor=ret_packets,\n                )\n                self.packets.append(ack_packet)\n\n        elif not isinstance(self.src, vUser) and isinstance(self.dst, vUser):\n            if self.dst_process_length &gt; 0:\n                logger.warning(\n                    f\"{simulation.now}:\\t{self} destination is a vUser, dst_instruction_length is ignored.\"\n                )\n\n            src_container = self.src.getContainer()\n\n            src_process = vContainerProcess(\n                container=src_container,\n                length=self.src_process_length,\n                priority=self.priority,\n                create_at=simulation.now,\n                label=f\"{self}-SRC\",\n            )\n            self.processes.append(src_process)\n\n            src_packets: List[Entity] = list()\n            for i in range(self.num_ack_packets):\n                src_packet = vPacket(\n                    src=src_container,\n                    dst=self.dst,\n                    size=self.src_packet_size,\n                    priority=self.priority,\n                    create_at=simulation.now,\n                    label=f\"{self}-SRC-{i}\",\n                    precursor=src_process,\n                )\n                self.packets.append(src_packet)\n                src_packets.append(src_packet)\n\n            ret_packets: List[Entity] = list()\n            for i in range(self.num_ret_packets):\n                ret_packet = vPacket(\n                    src=self.dst,\n                    dst=src_container,\n                    size=self.ret_packet_size,\n                    priority=self.priority,\n                    create_at=simulation.now,\n                    label=f\"{self}-RET-{i}\",\n                    precursor=src_packets,\n                )\n                self.packets.append(ret_packet)\n                ret_packets.append(ret_packet)\n\n            ack_process = vContainerProcess(\n                container=src_container,\n                length=self.ack_process_length,\n                priority=self.priority,\n                precursor=ret_packets,\n                create_at=simulation.now,\n                label=f\"{self}-ACK\",\n            )\n            self.processes.append(ack_process)\n\n            for i in range(self.num_ack_packets):\n                ack_packet = vPacket(\n                    src=src_container,\n                    dst=self.dst,\n                    size=self.ack_packet_size,\n                    priority=self.priority,\n                    create_at=simulation.now,\n                    label=f\"{self}-ACK-{i}\",\n                    precursor=ack_process,\n                )\n                self.packets.append(ack_packet)\n\n        elif not isinstance(self.src, vUser) and not isinstance(self.dst, vUser):\n\n            src_container = self.src.getContainer()\n            dst_container = self.dst.getContainer()\n\n            src_process = vContainerProcess(\n                container=src_container,\n                length=self.src_process_length,\n                priority=self.priority,\n                create_at=simulation.now,\n                label=f\"{self}-SRC\",\n            )\n            self.processes.append(src_process)\n\n            src_packets: List[Entity] = list()\n            for i in range(self.num_src_packets):\n                src_packet = vPacket(\n                    src=src_container,\n                    dst=dst_container,\n                    size=self.src_packet_size,\n                    priority=self.priority,\n                    create_at=simulation.now,\n                    label=f\"{self}-SRC-{i}\",\n                    precursor=src_process,\n                )\n                self.packets.append(src_packet)\n                src_packets.append(src_packet)\n\n            dst_process = vContainerProcess(\n                container=dst_container,\n                length=self.dst_process_length,\n                priority=self.priority,\n                precursor=src_packets,\n                create_at=simulation.now,\n                label=f\"{self}-DST\",\n            )\n            self.processes.append(dst_process)\n\n            ret_packets: List[Entity] = list()\n            for i in range(self.num_ret_packets):\n                ret_packet = vPacket(\n                    src=dst_container,\n                    dst=src_container,\n                    size=self.ret_packet_size,\n                    priority=self.priority,\n                    create_at=simulation.now,\n                    label=f\"{self}-RET-{i}\",\n                    precursor=dst_process,\n                )\n                self.packets.append(ret_packet)\n                ret_packets.append(ret_packet)\n\n            ack_process = vContainerProcess(\n                container=src_container,\n                length=self.ack_process_length,\n                priority=self.priority,\n                precursor=ret_packets,\n                create_at=simulation.now,\n                label=f\"{self}-ACK\",\n            )\n            self.processes.append(ack_process)\n\n            for i in range(self.num_ack_packets):\n                ack_packet = vPacket(\n                    src=src_container,\n                    dst=dst_container,\n                    size=self.ack_packet_size,\n                    priority=self.priority,\n                    create_at=simulation.now,\n                    label=f\"{self}-ACK-{i}\",\n                    precursor=ack_process,\n                )\n                self.packets.append(ack_packet)\n\n        @self.continuous_event(\n            at=simulation.now,\n            interval=simulation.min_time_unit,\n            duration=inf,\n            label=f\"{self}-Monitor\",\n        )\n        def monitoring():\n            if any([process.failed for process in self.processes]) or any(\n                [packet.failed for packet in self.packets]\n            ):\n                self.fail(simulation.now)\n                return\n\n            if all([process.succeed for process in self.processes]) and all(\n                [packet.succeed for packet in self.packets]\n            ):\n                self.success(simulation.now)\n                return\n\n        logger.info(\n            f\"{simulation.now}:\\t{self} is initiated {self} between {self.src} and {self.dst}.\"\n        )\n\n    def on_termination(self):\n        super().on_termination()\n        for process in self.processes:\n            process.fail(simulation.now)\n        logger.info(f\"{simulation.now}:\\t{self} terminated.\")\n\n    def on_destruction(self):\n        super().on_termination()\n        for process in self.processes:\n            process.fail(simulation.now)\n\n    def on_success(self):\n        super().on_success()\n        logger.info(f\"{simulation.now}:\\t{self} succeeded.\")\n\n    def on_fail(self):\n        super().on_fail()\n        logger.info(f\"{simulation.now}:\\t{self} failed.\")\n\n    @property\n    def src(self) -&gt; vMicroservice | vUser:\n        \"\"\"Return the source of the API call.\"\"\"\n        return self._src\n\n    @property\n    def dst(self) -&gt; vMicroservice | vUser:\n        \"\"\"Return the destination of the API call.\"\"\"\n        return self._dst\n\n    @property\n    def priority(self) -&gt; int:\n        \"\"\"Return the priority of the API call.\"\"\"\n        return self._priority\n\n    @property\n    def packets(self) -&gt; List[vPacket]:\n        \"\"\"Return the packets of the API call.\"\"\"\n        return self._packets\n\n    @property\n    def processes(self) -&gt; List[vContainerProcess]:\n        \"\"\"Return the processes of the API call.\"\"\"\n        return self._processes\n\n    @property\n    def src_process_length(self) -&gt; int:\n        \"\"\"Return the src_instruction_length\"\"\"\n        return self._src_process_length\n\n    @property\n    def dst_process_length(self) -&gt; int:\n        \"\"\"Return the dst_instruction_length\"\"\"\n        return self._dst_process_length\n\n    @property\n    def ack_process_length(self) -&gt; int:\n        \"\"\"Return the ack_instruction_length\"\"\"\n        return self._ack_process_length\n\n    @property\n    def num_src_packets(self) -&gt; int:\n        \"\"\"Return the num_src_packets\"\"\"\n        return self._num_src_packets\n\n    @property\n    def src_packet_size(self) -&gt; int:\n        \"\"\"Return the src_packet_size\"\"\"\n        return self._src_packet_size\n\n    @property\n    def num_ret_packets(self) -&gt; int:\n        \"\"\"Return the num_ret_packets\"\"\"\n        return self._num_ret_packets\n\n    @property\n    def ret_packet_size(self) -&gt; int:\n        \"\"\"Return the ret_packet_size\"\"\"\n        return self._ret_packet_size\n\n    @property\n    def num_ack_packets(self) -&gt; int:\n        \"\"\"Return the num_ack_packets\"\"\"\n        return self._num_ack_packets\n\n    @property\n    def ack_packet_size(self) -&gt; int:\n        \"\"\"Return the ack_packet_size\"\"\"\n        return self._ack_packet_size\n</code></pre>"},{"location":"api/software_entity/process_packet_apicall/vapicall/#PyCloudSim.entity.v_apicall.vAPICall.ack_packet_size","title":"<code>ack_packet_size: int</code>  <code>property</code>","text":"<p>Return the ack_packet_size</p>"},{"location":"api/software_entity/process_packet_apicall/vapicall/#PyCloudSim.entity.v_apicall.vAPICall.ack_process_length","title":"<code>ack_process_length: int</code>  <code>property</code>","text":"<p>Return the ack_instruction_length</p>"},{"location":"api/software_entity/process_packet_apicall/vapicall/#PyCloudSim.entity.v_apicall.vAPICall.dst","title":"<code>dst: vMicroservice | vUser</code>  <code>property</code>","text":"<p>Return the destination of the API call.</p>"},{"location":"api/software_entity/process_packet_apicall/vapicall/#PyCloudSim.entity.v_apicall.vAPICall.dst_process_length","title":"<code>dst_process_length: int</code>  <code>property</code>","text":"<p>Return the dst_instruction_length</p>"},{"location":"api/software_entity/process_packet_apicall/vapicall/#PyCloudSim.entity.v_apicall.vAPICall.num_ack_packets","title":"<code>num_ack_packets: int</code>  <code>property</code>","text":"<p>Return the num_ack_packets</p>"},{"location":"api/software_entity/process_packet_apicall/vapicall/#PyCloudSim.entity.v_apicall.vAPICall.num_ret_packets","title":"<code>num_ret_packets: int</code>  <code>property</code>","text":"<p>Return the num_ret_packets</p>"},{"location":"api/software_entity/process_packet_apicall/vapicall/#PyCloudSim.entity.v_apicall.vAPICall.num_src_packets","title":"<code>num_src_packets: int</code>  <code>property</code>","text":"<p>Return the num_src_packets</p>"},{"location":"api/software_entity/process_packet_apicall/vapicall/#PyCloudSim.entity.v_apicall.vAPICall.packets","title":"<code>packets: List[vPacket]</code>  <code>property</code>","text":"<p>Return the packets of the API call.</p>"},{"location":"api/software_entity/process_packet_apicall/vapicall/#PyCloudSim.entity.v_apicall.vAPICall.priority","title":"<code>priority: int</code>  <code>property</code>","text":"<p>Return the priority of the API call.</p>"},{"location":"api/software_entity/process_packet_apicall/vapicall/#PyCloudSim.entity.v_apicall.vAPICall.processes","title":"<code>processes: List[vContainerProcess]</code>  <code>property</code>","text":"<p>Return the processes of the API call.</p>"},{"location":"api/software_entity/process_packet_apicall/vapicall/#PyCloudSim.entity.v_apicall.vAPICall.ret_packet_size","title":"<code>ret_packet_size: int</code>  <code>property</code>","text":"<p>Return the ret_packet_size</p>"},{"location":"api/software_entity/process_packet_apicall/vapicall/#PyCloudSim.entity.v_apicall.vAPICall.src","title":"<code>src: vMicroservice | vUser</code>  <code>property</code>","text":"<p>Return the source of the API call.</p>"},{"location":"api/software_entity/process_packet_apicall/vapicall/#PyCloudSim.entity.v_apicall.vAPICall.src_packet_size","title":"<code>src_packet_size: int</code>  <code>property</code>","text":"<p>Return the src_packet_size</p>"},{"location":"api/software_entity/process_packet_apicall/vapicall/#PyCloudSim.entity.v_apicall.vAPICall.src_process_length","title":"<code>src_process_length: int</code>  <code>property</code>","text":"<p>Return the src_instruction_length</p>"},{"location":"api/software_entity/process_packet_apicall/vapicall/#PyCloudSim.entity.v_apicall.vAPICall.__init__","title":"<code>__init__(src, dst, priority, src_process_length, dst_process_length, ack_process_length, num_src_packets, src_packet_size, num_ret_packets, ret_packet_size, num_ack_packets, ack_packet_size, label=None, create_at=None, terminate_at=None, precursor=None)</code>","text":"<p>Create a new vAPICall.</p> <p>Parameters:</p> Name Type Description Default <code>src</code> <code>vMicroservice | vUser</code> <p>the source of the API call.</p> required <code>dst</code> <code>vMicroservice | vUser</code> <p>the destination of the API call.</p> required <code>priority</code> <code>int | Callable[..., int]</code> <p>the priority of the API call.</p> required <code>src_process_length</code> <code>int | Callable[..., int]</code> <p>the length of the source process.</p> required <code>dst_process_length</code> <code>int | Callable[..., int]</code> <p>the length of the destination process.</p> required <code>ack_process_length</code> <code>int | Callable[..., int]</code> <p>the length of the ack process.</p> required <code>num_src_packets</code> <code>int | Callable[..., int]</code> <p>the number of packets from source.</p> required <code>src_packet_size</code> <code>int | Callable[..., int]</code> <p>the size of the packets from source.</p> required <code>num_ret_packets</code> <code>int | Callable[..., int]</code> <p>the number of packets returned from destination.</p> required <code>ret_packet_size</code> <code>int | Callable[..., int]</code> <p>the size of the packets returned from destination.</p> required <code>num_ack_packets</code> <code>int | Callable[..., int]</code> <p>the number of packets from source for ACK.</p> required <code>ack_packet_size</code> <code>int | Callable[..., int]</code> <p>the size of the packets from source for ACK.</p> required <code>label</code> <code>str | None</code> <p>short description of this vAPICall. Defaults to None.</p> <code>None</code> <code>create_at</code> <code>int | float | Callable[..., int] | Callable[..., float] | None</code> <p>when this vAPICall should be created. Defaults to None.</p> <code>None</code> <code>terminate_at</code> <code>int | float | Callable[..., int] | Callable[..., float] | None</code> <p>when this vAPICall shoudl be terminated. Defaults to None.</p> <code>None</code> <code>precursor</code> <code>Entity | List[Entity] | None</code> <p>the precursor of this vAPICall. Defaults to None.</p> <code>None</code> Source code in <code>PyCloudSim\\entity\\v_apicall.py</code> <pre><code>def __init__(\n    self,\n    src: vMicroservice | vUser,\n    dst: vMicroservice | vUser,\n    priority: int | Callable[..., int],\n    src_process_length: int | Callable[..., int],\n    dst_process_length: int | Callable[..., int],\n    ack_process_length: int | Callable[..., int],\n    num_src_packets: int | Callable[..., int],\n    src_packet_size: int | Callable[..., int],\n    num_ret_packets: int | Callable[..., int],\n    ret_packet_size: int | Callable[..., int],\n    num_ack_packets: int | Callable[..., int],\n    ack_packet_size: int | Callable[..., int],\n    label: str | None = None,\n    create_at: int\n    | float\n    | Callable[..., int]\n    | Callable[..., float]\n    | None = None,\n    terminate_at: int\n    | float\n    | Callable[..., int]\n    | Callable[..., float]\n    | None = None,\n    precursor: Entity | List[Entity] | None = None,\n) -&gt; None:\n    \"\"\"Create a new vAPICall.\n\n    Args:\n        src (vMicroservice | vUser): the source of the API call.\n        dst (vMicroservice | vUser): the destination of the API call.\n        priority (int | Callable[..., int]): the priority of the API call.\n        src_process_length (int | Callable[..., int]): the length of the source process.\n        dst_process_length (int | Callable[..., int]): the length of the destination process.\n        ack_process_length (int | Callable[..., int]): the length of the ack process.\n        num_src_packets (int | Callable[..., int]): the number of packets from source.\n        src_packet_size (int | Callable[..., int]): the size of the packets from source.\n        num_ret_packets (int | Callable[..., int]): the number of packets returned from destination.\n        ret_packet_size (int | Callable[..., int]): the size of the packets returned from destination.\n        num_ack_packets (int | Callable[..., int]): the number of packets from source for ACK.\n        ack_packet_size (int | Callable[..., int]): the size of the packets from source for ACK.\n        label (str | None, optional): short description of this vAPICall. Defaults to None.\n        create_at (int | float | Callable[..., int] | Callable[..., float] | None, optional): when this vAPICall should be created. Defaults to None.\n        terminate_at (int | float | Callable[..., int] | Callable[..., float] | None, optional): when this vAPICall shoudl be terminated. Defaults to None.\n        precursor (Entity | List[Entity] | None, optional): the precursor of this vAPICall. Defaults to None.\n    \"\"\"\n    super().__init__(label, create_at, terminate_at, precursor)\n    self._src = src\n    self._dst = dst\n    self._type = type\n    if callable(priority):\n        self._priority = round(priority())\n    else:\n        self._priority = priority\n    if callable(src_process_length):\n        self._src_process_length = round(src_process_length())\n    else:\n        self._src_process_length = src_process_length\n    if callable(dst_process_length):\n        self._dst_process_length = round(dst_process_length())\n    else:\n        self._dst_process_length = dst_process_length\n    if callable(ack_process_length):\n        self._ack_process_length = round(ack_process_length())\n    else:\n        self._ack_process_length = ack_process_length\n    if callable(num_src_packets):\n        self._num_src_packets = round(num_src_packets())\n    else:\n        self._num_src_packets = num_src_packets\n    if callable(src_packet_size):\n        self._src_packet_size = round(src_packet_size())\n    else:\n        self._src_packet_size = src_packet_size\n    if callable(num_ret_packets):\n        self._num_ret_packets = round(num_ret_packets())\n    else:\n        self._num_ret_packets = num_ret_packets\n    if callable(ret_packet_size):\n        self._ret_packet_size = round(ret_packet_size())\n    else:\n        self._ret_packet_size = ret_packet_size\n    if callable(num_ack_packets):\n        self._num_ack_packets = round(num_ack_packets())\n    else:\n        self._num_ack_packets = num_ack_packets\n    if callable(ack_packet_size):\n        self._ack_packet_size = round(ack_packet_size())\n    else:\n        self._ack_packet_size = ack_packet_size\n\n    self._packets: List[vPacket] = [] # EntityList(label=f\"{self} Packets\")\n    self._processes: List[vContainerProcess] = [] # EntityList(label=f\"{self} Processes\")\n    simulation.api_calls.append(self)\n</code></pre>"},{"location":"api/software_entity/process_packet_apicall/vapicall/#PyCloudSim.entity.v_apicall.vAPICall.on_initiate","title":"<code>on_initiate()</code>","text":"<p>Initiate the vAPICall.</p> Source code in <code>PyCloudSim\\entity\\v_apicall.py</code> <pre><code>def on_initiate(self) -&gt; None:\n    \"\"\"Initiate the vAPICall.\n    \"\"\"\n    super().on_initiate()\n    if isinstance(self.src, vUser) and isinstance(self.dst, vUser):\n        if self.src_process_length &gt; 0:\n            logger.warning(\n                f\"{simulation.now}:\\t{self} source is a vUser, src_instruction_length is ignored.\"\n            )\n        if self.dst_process_length &gt; 0:\n            logger.warning(\n                f\"{simulation.now}:\\t{self} destination is a vUser, dst_instruction_length is ignored.\"\n            )\n        if self.ack_process_length &gt; 0:\n            logger.warning(\n                f\"{simulation.now}:\\t{self} source is a vUser, ack_instruction_length is ignored.\"\n            )\n\n        if self.num_src_packets &lt;= 0:\n            logger.error(\n                f\"{simulation.now}:\\t{self} invalid vAPICall configuration.\"\n            )\n            self.terminate(simulation.now)\n            return\n\n        src_packets: List[Entity] = list()\n        for i in range(self.num_src_packets):\n            src_packet = vPacket(\n                src=self.src,\n                dst=self.dst,\n                size=self.src_packet_size,\n                priority=self.priority,\n                create_at=simulation.now,\n                label=f\"{self}-SRC-{i}\",\n            )\n            self.packets.append(src_packet)\n            src_packets.append(src_packet)\n\n        ret_packets: List[Entity] = list()\n        for i in range(self.num_ret_packets):\n            ret_packet = vPacket(\n                src=self.dst,\n                dst=self.src,\n                size=self.ret_packet_size,\n                priority=self.priority,\n                create_at=simulation.now,\n                label=f\"{self}-RET-{i}\",\n                precursor=src_packets,\n            )\n            self.packets.append(ret_packet)\n            ret_packets.append(ret_packet)\n\n        ack_packets: List[Entity] = list()\n        for i in range(self.num_ack_packets):\n            ack_packet = vPacket(\n                src=self.src,\n                dst=self.dst,\n                size=self.ack_packet_size,\n                priority=self.priority,\n                create_at=simulation.now,\n                label=f\"{self}-ACK-{i}\",\n                precursor=ret_packets,\n            )\n            self.packets.append(ack_packet)\n            ack_packets.append(ack_packet)\n\n    elif isinstance(self.src, vUser) and not isinstance(self.dst, vUser):\n        if self.src_process_length &gt; 0:\n            logger.warning(\n                f\"{simulation.now}:\\t{self} source is a vUser, src_instruction_length is ignored.\"\n            )\n        if self.ack_process_length &gt; 0:\n            logger.warning(\n                f\"{simulation.now}:\\t{self} source is a vUser, ack_instruction_length is ignored.\"\n            )\n\n        if self.num_src_packets &lt;= 0:\n            logger.error(\n                f\"{simulation.now}:\\t{self} invalid vAPICall configuration.\"\n            )\n            self.terminate(simulation.now)\n            return\n\n        dst_container = self.dst.getContainer()\n\n        src_packets: List[Entity] = list()\n        for i in range(self.num_src_packets):\n            src_packet = vPacket(\n                src=self.src,\n                dst=dst_container,\n                size=self.src_packet_size,\n                priority=self.priority,\n                create_at=simulation.now,\n                label=f\"{self}-SRC-{i}\",\n            )\n            self.packets.append(src_packet)\n            src_packets.append(src_packet)\n\n        dst_process = vContainerProcess(\n            container=self.dst.getContainer(),\n            length=self.dst_process_length,\n            priority=self.priority,\n            precursor=src_packets,\n            create_at=simulation.now,\n            label=f\"{self}-DST\",\n        )\n\n        ret_packets: List[Entity] = list()\n        for i in range(self.num_ret_packets):\n            ret_packet = vPacket(\n                src=dst_container,\n                dst=self.src,\n                size=self.ret_packet_size,\n                priority=self.priority,\n                create_at=simulation.now,\n                label=f\"{self}-RET-{i}\",\n                precursor=dst_process,\n            )\n            self.packets.append(ret_packet)\n            ret_packets.append(ret_packet)\n\n        for i in range(self.num_ack_packets):\n            ack_packet = vPacket(\n                src=self.src,\n                dst=dst_container,\n                size=self.ack_packet_size,\n                priority=self.priority,\n                create_at=simulation.now,\n                label=f\"{self}-ACK-{i}\",\n                precursor=ret_packets,\n            )\n            self.packets.append(ack_packet)\n\n    elif not isinstance(self.src, vUser) and isinstance(self.dst, vUser):\n        if self.dst_process_length &gt; 0:\n            logger.warning(\n                f\"{simulation.now}:\\t{self} destination is a vUser, dst_instruction_length is ignored.\"\n            )\n\n        src_container = self.src.getContainer()\n\n        src_process = vContainerProcess(\n            container=src_container,\n            length=self.src_process_length,\n            priority=self.priority,\n            create_at=simulation.now,\n            label=f\"{self}-SRC\",\n        )\n        self.processes.append(src_process)\n\n        src_packets: List[Entity] = list()\n        for i in range(self.num_ack_packets):\n            src_packet = vPacket(\n                src=src_container,\n                dst=self.dst,\n                size=self.src_packet_size,\n                priority=self.priority,\n                create_at=simulation.now,\n                label=f\"{self}-SRC-{i}\",\n                precursor=src_process,\n            )\n            self.packets.append(src_packet)\n            src_packets.append(src_packet)\n\n        ret_packets: List[Entity] = list()\n        for i in range(self.num_ret_packets):\n            ret_packet = vPacket(\n                src=self.dst,\n                dst=src_container,\n                size=self.ret_packet_size,\n                priority=self.priority,\n                create_at=simulation.now,\n                label=f\"{self}-RET-{i}\",\n                precursor=src_packets,\n            )\n            self.packets.append(ret_packet)\n            ret_packets.append(ret_packet)\n\n        ack_process = vContainerProcess(\n            container=src_container,\n            length=self.ack_process_length,\n            priority=self.priority,\n            precursor=ret_packets,\n            create_at=simulation.now,\n            label=f\"{self}-ACK\",\n        )\n        self.processes.append(ack_process)\n\n        for i in range(self.num_ack_packets):\n            ack_packet = vPacket(\n                src=src_container,\n                dst=self.dst,\n                size=self.ack_packet_size,\n                priority=self.priority,\n                create_at=simulation.now,\n                label=f\"{self}-ACK-{i}\",\n                precursor=ack_process,\n            )\n            self.packets.append(ack_packet)\n\n    elif not isinstance(self.src, vUser) and not isinstance(self.dst, vUser):\n\n        src_container = self.src.getContainer()\n        dst_container = self.dst.getContainer()\n\n        src_process = vContainerProcess(\n            container=src_container,\n            length=self.src_process_length,\n            priority=self.priority,\n            create_at=simulation.now,\n            label=f\"{self}-SRC\",\n        )\n        self.processes.append(src_process)\n\n        src_packets: List[Entity] = list()\n        for i in range(self.num_src_packets):\n            src_packet = vPacket(\n                src=src_container,\n                dst=dst_container,\n                size=self.src_packet_size,\n                priority=self.priority,\n                create_at=simulation.now,\n                label=f\"{self}-SRC-{i}\",\n                precursor=src_process,\n            )\n            self.packets.append(src_packet)\n            src_packets.append(src_packet)\n\n        dst_process = vContainerProcess(\n            container=dst_container,\n            length=self.dst_process_length,\n            priority=self.priority,\n            precursor=src_packets,\n            create_at=simulation.now,\n            label=f\"{self}-DST\",\n        )\n        self.processes.append(dst_process)\n\n        ret_packets: List[Entity] = list()\n        for i in range(self.num_ret_packets):\n            ret_packet = vPacket(\n                src=dst_container,\n                dst=src_container,\n                size=self.ret_packet_size,\n                priority=self.priority,\n                create_at=simulation.now,\n                label=f\"{self}-RET-{i}\",\n                precursor=dst_process,\n            )\n            self.packets.append(ret_packet)\n            ret_packets.append(ret_packet)\n\n        ack_process = vContainerProcess(\n            container=src_container,\n            length=self.ack_process_length,\n            priority=self.priority,\n            precursor=ret_packets,\n            create_at=simulation.now,\n            label=f\"{self}-ACK\",\n        )\n        self.processes.append(ack_process)\n\n        for i in range(self.num_ack_packets):\n            ack_packet = vPacket(\n                src=src_container,\n                dst=dst_container,\n                size=self.ack_packet_size,\n                priority=self.priority,\n                create_at=simulation.now,\n                label=f\"{self}-ACK-{i}\",\n                precursor=ack_process,\n            )\n            self.packets.append(ack_packet)\n\n    @self.continuous_event(\n        at=simulation.now,\n        interval=simulation.min_time_unit,\n        duration=inf,\n        label=f\"{self}-Monitor\",\n    )\n    def monitoring():\n        if any([process.failed for process in self.processes]) or any(\n            [packet.failed for packet in self.packets]\n        ):\n            self.fail(simulation.now)\n            return\n\n        if all([process.succeed for process in self.processes]) and all(\n            [packet.succeed for packet in self.packets]\n        ):\n            self.success(simulation.now)\n            return\n\n    logger.info(\n        f\"{simulation.now}:\\t{self} is initiated {self} between {self.src} and {self.dst}.\"\n    )\n</code></pre>"}]}